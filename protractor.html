<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Protractor</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1720; --muted:#96a0ad; --accent:#2ee2c4; --accent2:#ff6b6b;
    --text:#e6eef6; --card:#0d1620;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:Inter, ui-sans-serif, system-ui, monospace;}
  .wrap{display:flex; gap:18px; padding:18px; align-items:flex-start; max-width:1200px; margin:0 auto;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04)); border-radius:10px; padding:14px; box-shadow:0 6px 22px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03);}
  .left{width:720px;}
  .right{width:320px; display:flex; flex-direction:column; gap:14px;}
  h2{margin:0 0 10px 0; color:var(--accent);}
  svg{width:100%; height:600px; display:block; background:transparent;}
  .controls{display:flex; flex-direction:column; gap:8px; margin-top:10px;}
  label{font-size:13px; color:var(--muted);}
  input[type=range]{width:100%;}
  .row{display:flex; gap:8px; align-items:center; }
  select, button{padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:rgba(255,255,255,0.02); color:var(--muted); cursor:pointer;}
  .small{font-size:12px; color:var(--muted);}
  .tooltip{position:absolute; pointer-events:none; background:#061018; border:1px solid rgba(255,255,255,0.06); padding:6px 8px; border-radius:6px; font-size:12px; color:var(--text);}
  .clockCard{display:flex; flex-direction:column; align-items:center; gap:8px; padding:12px; width:100%;}
  .muted{color:var(--muted); font-size:13px;}
  .export{display:flex; gap:8px;}
</style>
</head>
<body>
<div class="wrap">
  <div class="card left">
    <h2>RAU Protractor — interactive</h2>
    <div style="position:relative;">
      <svg id="prosvg" viewBox="-260 -20 520 10" preserveAspectRatio="xMidYMid meet">
        <!-- we draw into this SVG via JS -->
      </svg>
      <div id="tooltip" class="tooltip" style="display:none;"></div>
    </div>

    <div class="controls">
      <div class="row">
        <label style="flex:1">Ticks:</label>
        <input id="tickCount" type="range" min="4" max="120" step="1" value="24" />
        <div class="small" id="tickVal">24</div>
      </div>

      <div class="row">
        <label style="flex:1">Label mode:</label>
        <select id="labelMode">
          <option value="t">t (RAU param)</option>
          <option value="deg">degrees</option>
          <option value="rad">radians</option>
          <option value="none">none</option>
        </select>
        <button id="snapCenter">Snap center</button>
      </div>

      <div class="row">
        <label style="flex:1">Arc radius (px):</label>
        <input id="radius" type="range" min="120" max="220" step="1" value="200" />
        <div class="small" id="radiusVal">200</div>
      </div>

      <div class="row export">
        <button id="exportSvg">Export SVG</button>
        <button id="reset">Reset</button>
        <div style="flex:1;"></div>
      </div>
    </div>
  </div>

  <div class="card right">
    <div class="clockCard">
      <div class="muted">RAU clock demo</div>

        <g id="clockTicks"></g>
        <g id="handGroup">
          <line id="hand" x1="0" y1="0" x2="80" y2="0" stroke="url(#handGrad)" stroke-width="6" stroke-linecap="round" transform="rotate(0)"/>
          <circle cx="0" cy="0" r="6" fill="#fff"/>
        </g>
      </svg>
      <div class="muted">RAU t: <span id="curT">0.0</span> — θ: <span id="curDeg">0°</span></div>
      <div style="display:flex; gap:8px;">
        <button id="animateToggle">Animate</button>
      </div>
    </div>

  </div>
</div>

<script>
/* ---------- RAU math utilities (reusable) ---------- */
const RAU = (function(){
  const pi = Math.PI;
  return {
    // t in [0,1] -> vector (x,y) normalized direction of (1-t, t)
    tToVector(t){
      // vector = (1-t, t) ; normalize
      const vx = 1 - t, vy = t;
      const len = Math.hypot(vx, vy) || 1;
      return { x: vx/len, y: vy/len };
    },
    // t -> angle in radians (standard polar angle measured from +x towards +y)
    tToAngle(t){
      const v = this.tToVector(t);
      return Math.atan2(v.y, v.x); // range (-pi,pi) but for t in [0,1] gives [0,pi/2]
    },
    // angle (radians) -> t (inverse mapping), theta in (0, pi/2)
    angleToT(theta){
      // tan(theta) = t/(1-t) => t = tan/(1+tan)
      const tanv = Math.tan(theta);
      const t = tanv / (1 + tanv);
      // clamp
      return Math.max(0, Math.min(1, t));
    },
    // format helpers
    formatT(t, decimals=3){ return t.toFixed(decimals); },
    formatDeg(theta, decimals=2){ return (theta*180/Math.PI).toFixed(decimals); },
    formatRad(theta, decimals=3){ return theta.toFixed(decimals); }
  };
})();

/* ---------- Rendering code ---------- */
const svg = document.getElementById('prosvg');
const tooltip = document.getElementById('tooltip');
let state = {
  ticks: 24,
  radius: 200,
  labelMode: 't',
  curT: 0.0
};

const NS = "http://www.w3.org/2000/svg";
function create(tag, attrs={}) {
  const el = document.createElementNS(NS, tag);
  for(const k in attrs) el.setAttribute(k, attrs[k]);
  return el;
}

// Clear svg
function clearSvg() {
  while(svg.firstChild) svg.removeChild(svg.firstChild);
}

// draw protractor base (quarter circle from 0..90deg)
function drawProtractor(){
  clearSvg();
  const R = state.radius;
  // center at (0,0) for simplicity but shifted a bit so tick labels fit
  const cx = 0, cy = 0;

  // Quarter circle path from angle 0->90 (SVG coordinates: y down -> we use negative for up)
  const start = {x: R, y: 0}, end = {x: 0, y: -R};
  const arcPath = `M ${start.x} ${start.y} A ${R} ${R} 0 0 0 ${end.x} ${end.y}`;
  const arc = create('path', {d:arcPath, stroke: 'rgba(255,255,255,0.06)', 'stroke-width':2, fill:'none'});
  svg.appendChild(arc);

  // center / origin
  const origin = create('circle', {cx:0, cy:0, r:3, fill:'#fff'});
  svg.appendChild(origin);

  // draw ticks uniformly in t
  const ticks = state.ticks;
  for(let i=0;i<=ticks;i++){
    const t = i / ticks;
    const v = RAU.tToVector(t);
    // screen coords: use (x*R, -y*R) because in math +y is up
    const px = v.x * R, py = -v.y * R;
    // tick length
    const inner = {x: v.x*(R-8), y: -v.y*(R-8)};
    const line = create('line', {
      x1: px, y1: py, x2: inner.x, y2: inner.y,
      stroke: (i%4===0? 'rgba(46,226,196,0.95)': 'rgba(255,255,255,0.12)'),
      'stroke-width': (i%4===0?2:1)
    });
    svg.appendChild(line);

    // add clickable clickable area (small circle) for snap
    const hit = create('circle', {cx: px, cy: py, r:6, fill:'transparent', 'data-t': t});
    hit.style.cursor='pointer';
    hit.addEventListener('click', (ev)=>{ setTAndUpdate(t); ev.stopPropagation(); });
    svg.appendChild(hit);
  
  // labels
  const labelMode = state.labelMode;
  if(labelMode !== 'none' && (i === 0 || i === ticks || i % Math.max(1, Math.floor(ticks/12)) === 0)){
      let text = '';
      if(labelMode === 't') text = RAU.formatT(t,3);
      else if(labelMode === 'deg') text = RAU.formatDeg(RAU.tToAngle(t),1) + '°';
      else if(labelMode === 'rad') text = RAU.formatRad(RAU.tToAngle(t),2) + 'r';
  
      // compute rotated position + rotation angle
      const theta = RAU.tToAngle(t);
      const deg = -theta * 180 / Math.PI;
  
      // pushing label slightly outside radius
      const lx = v.x * (R + 18);
      const ly = -v.y * (R + 18);
  
      const tx = create('text', {
          x: lx,
          y: ly,
          fill:'#dff8f3',
          'font-size': (i%4===0 ? 12 : 10),
          'text-anchor':'middle',
          'dominant-baseline':'middle',
          transform: `rotate(${deg} ${lx} ${ly})`
      });
      tx.textContent = text;
      svg.appendChild(tx);
  }
}
  // overlay interactive arc to capture clicks anywhere on arc
  const arcHot = create('path', {d: arcPath, stroke:'transparent', 'stroke-width':20, fill:'none', id:'arcHot'});
  arcHot.style.cursor='pointer';
  arcHot.addEventListener('mousemove', handleArcHover);
  arcHot.addEventListener('mouseout', ()=>{ tooltip.style.display='none'; });
  arcHot.addEventListener('click', handleArcClick);
  svg.appendChild(arcHot);

  // Draw current angle ray
  drawCurrentRay();

  // small center guide line for angle zero
  const axis = create('line', {x1:0,y1:0,x2:R,y2:0, stroke:'rgba(255,255,255,0.03)', 'stroke-width':1});
  svg.appendChild(axis);
}

// draw the ray for current t
function drawCurrentRay(){
  // remove previous if any
  const old = svg.querySelector('#curRay');
  if(old) old.remove();
  const t = state.curT;
  const v = RAU.tToVector(t);
  const R = state.radius;
  const x = v.x*R, y = -v.y*R;
  const ray = create('line', {id:'curRay', x1:0, y1:0, x2:x, y2:y, stroke:'url(#g1)', 'stroke-width':4, 'stroke-linecap':'round'});
  // gradient for line
  let g = svg.querySelector('#g1');
  if(!g){
    g = create('defs');
    const lg = create('linearGradient'); lg.setAttribute('id','g1'); lg.setAttribute('x1','0'); lg.setAttribute('y1','0'); lg.setAttribute('x2','1'); lg.setAttribute('y2','1');
    const s1 = create('stop'); s1.setAttribute('offset','0'); s1.setAttribute('stop-color','#ff8d6b');
    const s2 = create('stop'); s2.setAttribute('offset','1'); s2.setAttribute('stop-color','#2ee2c4');
    lg.appendChild(s1); lg.appendChild(s2);
    g.appendChild(lg);
    svg.insertBefore(g, svg.firstChild);
  }
  svg.appendChild(ray);

  // marker at end
  const oldM = svg.querySelector('#curDot');
  if(oldM) oldM.remove();
  const dot = create('circle', {id:'curDot', cx:x, cy:y, r:6, fill:'#fff'});
  svg.appendChild(dot);
}

// handle hover on arc: compute closest t for cursor and show tooltip
function handleArcHover(evt){
  const pt = screenToSvg(evt.clientX, evt.clientY);
  // compute angle from +x axis: theta = atan2(-py, px)? careful with our coordinate sign (svg y positive downward)
  // our math uses center at 0,0 and up is negative y -> we used v.y negative for screen y
  // convert point back to math coordinates (x, -y)
  const mx = pt.x, my = pt.y; // svg coords
  // convert to math coords: (x, -y)
  const mathX = mx, mathY = -my;
  const theta = Math.atan2(mathY, mathX); // rad
  // clamp to [0, pi/2]
  const t = RAU.angleToT(theta);
  const deg = RAU.formatDeg(RAU.tToAngle(t));
  const rad = RAU.formatRad(RAU.tToAngle(t));
  tooltip.style.display='block';
  tooltip.style.left = (evt.clientX + 12) + 'px';
  tooltip.style.top = (evt.clientY + 12) + 'px';
  tooltip.innerHTML = `<strong>t</strong>: ${RAU.formatT(t,4)} <br><strong>θ</strong>: ${deg}° (${rad} rad)`;
}

// convert screen point to svg coordinates
function screenToSvg(clientX, clientY){
  const pt = svg.createSVGPoint();
  pt.x = clientX; pt.y = clientY;
  const ctm = svg.getScreenCTM().inverse();
  const sp = pt.matrixTransform(ctm);
  return {x: sp.x, y: sp.y};
}

function handleArcClick(evt){
  const pt = screenToSvg(evt.clientX, evt.clientY);
  const mathX = pt.x, mathY = -pt.y;
  const theta = Math.atan2(mathY, mathX);
  const t = RAU.angleToT(theta);
  setTAndUpdate(t);
}

// set current t and update UI and clock
function setTAndUpdate(t){
  state.curT = Math.max(0, Math.min(1, t));
  drawCurrentRay();
  updateClockFromT(state.curT);
  document.getElementById('curT').textContent = RAU.formatT(state.curT,4);
  document.getElementById('curDeg').textContent = RAU.formatDeg(RAU.tToAngle(state.curT)) + '°';
}

/* ---------- Clock widget code (demo) ---------- */
const hand = document.getElementById('hand');

function updateClockFromT(t){
  // convert RAU angle to degrees for rotation: angle measured from +x toward +y.
  const theta = RAU.tToAngle(t);
  // SVG clock: rotate in degrees clockwise? our angle is mathematical CCW. For display we'll convert to degrees and use rotate(-deg) because y down in SVG.
  const deg = theta * 180 / Math.PI;
  // set transform rotate(deg) about origin
  hand.setAttribute('transform', `rotate(${ -deg })`);
  // draw clock tick markers for reference (e.g., 0..90 marked)
  // show markers at uniform degrees optionally
  drawClockTicks();
}

// small clock ticks
function drawClockTicks(){

  const R=98;
  for(let a=0;a<360;a+=30){
    const rad = a * Math.PI/180;
    const x1 = Math.cos(rad)*(R-6), y1 = -Math.sin(rad)*(R-6);
    const x2 = Math.cos(rad)*R, y2 = -Math.sin(rad)*R;
    const ln = create('line', {x1:x1, y1:y1, x2:x2, y2:y2, stroke:'rgba(255,255,255,0.06)', 'stroke-width': (a%90===0?2:1)});
  }
}

/* ---------- UI wiring ---------- */
document.getElementById('tickCount').addEventListener('input', (e)=>{ state.ticks = +e.target.value; document.getElementById('tickVal').textContent = e.target.value; drawProtractor();});
document.getElementById('labelMode').addEventListener('change', (e)=>{ state.labelMode = e.target.value; drawProtractor();});
document.getElementById('radius').addEventListener('input', (e)=>{ state.radius = +e.target.value; document.getElementById('radiusVal').textContent = e.target.value; drawProtractor();});
document.getElementById('snapCenter').addEventListener('click', ()=>{ setTAndUpdate(0.5); });

document.getElementById('exportSvg').addEventListener('click', ()=>{
  // inline styles minimal; serialize svg and download
  const serializer = new XMLSerializer();
  const clone = svg.cloneNode(true);
  // embed style
  const svgText = serializer.serializeToString(clone);
  const blob = new Blob([svgText], {type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'rau-protractor.svg'; a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('reset').addEventListener('click', ()=>{
  state.ticks = 24; state.radius = 200; state.labelMode = 't'; state.curT = 0;
  document.getElementById('tickCount').value = state.ticks; document.getElementById('tickVal').textContent = state.ticks;
  document.getElementById('radius').value = state.radius; document.getElementById('radiusVal').textContent = state.radius;
  document.getElementById('labelMode').value = state.labelMode;
  setTAndUpdate(0);
  drawProtractor();
});

document.getElementById('animateToggle').addEventListener('click', (e)=>{
  if(e.target.dataset.playing === '1'){ e.target.dataset.playing='0'; e.target.textContent='Animate'; stopAnimation(); }
  else { e.target.dataset.playing='1'; e.target.textContent='Stop'; startAnimation(); }
});

svg.addEventListener('mousemove', (ev)=>{
  // show tooltip when near arc (we use arcHot's handler for arc), but also show positioned tooltip when hovering anywhere for convenience
});
svg.addEventListener('mouseleave', ()=>{ tooltip.style.display='none'; });

/* ---------- small animation demo (oscillate t) ---------- */
let animReq=null, animStart=0;
function startAnimation(){
  animStart = performance.now();
  function step(now){
    const t = ((now - animStart) * 0.00025) % 2;
    // triangle wave between 0..1
    let tri = Math.abs((t % 2) - 1);
    // optionally skew
    const skew = tri;
    const newT = 0.1 + 0.9 * skew;
    setTAndUpdate(newT);
    animReq = requestAnimationFrame(step);
  }
  animReq = requestAnimationFrame(step);
}
function stopAnimation(){ if(animReq) cancelAnimationFrame(animReq); animReq = null; }

/* ---------- initialization ---------- */
setTAndUpdate(0.0);
drawProtractor();
updateClockFromT(0.0);
drawClockTicks();

// Expose RAU to global for easy integration into other files
window.RAU = RAU;
window.setTAndUpdate = setTAndUpdate;
</script>
</body>
</html>
