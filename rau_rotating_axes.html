<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RAU Axis Reflection with Endpoint Labels</title>
<style>
  body {
    background: #fff;
    color: #222;
    text-align: center;
    font-family: monospace;
    margin: 0;
    padding: 10px;
  }
  canvas {
    border: 1px solid #ccc;
    margin-top: 10px;
    border-radius: 8px;
    background: #fff;
  }
  label { margin: 0 8px; }
</style>
</head>
<body>
<h2>RAU Axis Reflection — Symmetry Mapping</h2>
<canvas id="canvas" width="500" height="500"></canvas>
<br>
<label>Phase:
  <input type="range" id="slider" min="0" max="4" step="0.001" value="0">
</label>
<label><input type="checkbox" id="auto" checked> Auto</label>
<label>Speed:
  <input type="range" id="speed" min="0.1" max="2" step="0.1" value="0.15">
</label>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const slider = document.getElementById('slider');
const auto = document.getElementById('auto');
const speedSlider = document.getElementById('speed');

let t = 0, lastTime = 0;
let selectedPoint = null;
let hoveredPoint = null;
const points = [];

function getRAUComponents(f) {
  const a = 1 - 2*f + 2*f*f;
  const denom = 1 / Math.sqrt(a);
  const c = (1 - f) * denom;
  const s = f * denom;
  return { c, s };
}

function getRotationComponents(param) {
  const absVal = Math.abs(param);
  const quadrant = Math.floor(absVal) % 4;
  const fraction = absVal - quadrant;
  const { c, s } = getRAUComponents(fraction);
  let cos = 0, sin = 0;
  if (quadrant === 0) { cos = c; sin = s; }
  if (quadrant === 1) { cos = -s; sin = c; }
  if (quadrant === 2) { cos = -c; sin = -s; }
  if (quadrant === 3) { cos = s; sin = -c; }
  return { cos, sin, quadrant };
}

function calculateRelationship(p1, p2) {
  // Angle between points
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const distance = Math.sqrt(dx*dx + dy*dy);
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
  
  // Determine relationship type
  let relationship = "unknown";
  const cosDiff = Math.abs(parseFloat(p1.cosVal) - parseFloat(p2.cosVal));
  const sinDiff = Math.abs(parseFloat(p1.sinVal) - parseFloat(p2.sinVal));
  
  if (cosDiff < 0.01 && sinDiff < 0.01) {
    relationship = "same point";
  } else if (cosDiff < 0.01) {
    relationship = "reflected (cos)";
  } else if (sinDiff < 0.01) {
    relationship = "reflected (sin)";
  } else if (p1.color === p2.color) {
    relationship = "opposite (180°)";
  } else {
    relationship = "perpendicular (90°)";
  }
  
  return { angle: angle.toFixed(1), distance: distance.toFixed(1), relationship };
}

function drawAxes(param) {
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2, radius = 150;
  
  ctx.clearRect(0, 0, W, H);
  
  // Grid
  ctx.strokeStyle = "#f0f0f0";
  ctx.lineWidth = 1;
  for (let i = -4; i <= 4; i++) {
    ctx.beginPath();
    ctx.moveTo(0, cy + i*40);
    ctx.lineTo(W, cy + i*40);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx + i*40, 0);
    ctx.lineTo(cx + i*40, H);
    ctx.stroke();
  }
  
  // Circle outline
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI*2);
  ctx.stroke();
  
  // Get rotating axes
  const { cos, sin } = getRotationComponents(param % 4);
  
  // Four endpoints of perpendicular axes with computed coordinates
  const p1 = { 
    x: cx + cos*radius, 
    y: cy - sin*radius, 
    color: "#e74c3c",
    cosVal: cos.toFixed(3),
    sinVal: sin.toFixed(3),
    id: 0
  };
  const p2 = { 
    x: cx - cos*radius, 
    y: cy + sin*radius, 
    color: "#e74c3c",
    cosVal: (-cos).toFixed(3),
    sinVal: (-sin).toFixed(3),
    id: 1
  };
  const p3 = { 
    x: cx + sin*radius, 
    y: cy + cos*radius, 
    color: "#3498db",
    cosVal: sin.toFixed(3),
    sinVal: cos.toFixed(3),
    id: 2
  };
  const p4 = { 
    x: cx - sin*radius, 
    y: cy - cos*radius, 
    color: "#3498db",
    cosVal: (-sin).toFixed(3),
    sinVal: (-cos).toFixed(3),
    id: 3
  };
  
  points.length = 0;
  points.push(p1, p2, p3, p4);
  
  // X-axis line (red)
  ctx.strokeStyle = "#e74c3c";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(p2.x, p2.y);
  ctx.lineTo(p1.x, p1.y);
  ctx.stroke();
  
  // Y-axis line (blue)
  ctx.strokeStyle = "#3498db";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(p4.x, p4.y);
  ctx.lineTo(p3.x, p3.y);
  ctx.stroke();
  
  // Draw connection line if selected and hovering
  if (selectedPoint !== null && hoveredPoint !== null && selectedPoint !== hoveredPoint) {
    ctx.strokeStyle = "rgba(100, 100, 100, 0.5)";
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(points[selectedPoint].x, points[selectedPoint].y);
    ctx.lineTo(points[hoveredPoint].x, points[hoveredPoint].y);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // Draw points
  [p1, p2, p3, p4].forEach((p, idx) => {
    const isSelected = selectedPoint === idx;
    const isHovered = hoveredPoint === idx;
    
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, isSelected ? 10 : (isHovered ? 8 : 6), 0, Math.PI*2);
    ctx.fill();
    
    if (isSelected) {
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  
  // Position labels outside the circle
  const labelOffset = 50;
  
  [p1, p2, p3, p4].forEach(p => {
    const dx = p.x - cx;
    const dy = p.y - cy;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const dirX = dx / dist;
    const dirY = dy / dist;
    
    const labelX = p.x + dirX * labelOffset;
    const labelY = p.y + dirY * labelOffset;
    
    ctx.fillStyle = p.color;
    ctx.font = "bold 12px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`cos: ${p.cosVal}`, labelX, labelY - 8);
    ctx.fillText(`sin: ${p.sinVal}`, labelX, labelY + 8);
  });
  
  // Center origin
  ctx.fillStyle = "#999";
  ctx.beginPath();
  ctx.arc(cx, cy, 3, 0, Math.PI*2);
  ctx.fill();
  
  // Info
  ctx.fillStyle = "#000";
  ctx.font = "14px monospace";
  ctx.textAlign = "left";
  ctx.fillText(`RAU param: ${param.toFixed(3)}`, 15, 25);
  
  // Show relationship info
  if (selectedPoint !== null && hoveredPoint !== null && selectedPoint !== hoveredPoint) {
    const rel = calculateRelationship(points[selectedPoint], points[hoveredPoint]);
    ctx.font = "12px monospace";
    ctx.fillStyle = "#333";
    ctx.fillText(`Angle: ${rel.angle}°  Distance: ${rel.distance}`, 15, 45);
    ctx.fillText(`Relationship: ${rel.relationship}`, 15, 60);
  }
}

function animate(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  
  if (auto.checked) {
    const speed = parseFloat(speedSlider.value);
    t = (t + dt * 0.5 * speed) % 4;
    slider.value = t;
  }
  
  drawAxes(t);
  requestAnimationFrame(animate);
}

slider.addEventListener('input', () => {
  t = parseFloat(slider.value);
  drawAxes(t);
});

// Mouse click to select point
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  for (let i = 0; i < points.length; i++) {
    const dx = mouseX - points[i].x;
    const dy = mouseY - points[i].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 15) {
      selectedPoint = selectedPoint === i ? null : i;
      break;
    }
  }
});

// Mouse move to hover over points
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  hoveredPoint = null;
  for (let i = 0; i < points.length; i++) {
    const dx = mouseX - points[i].x;
    const dy = mouseY - points[i].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 15) {
      hoveredPoint = i;
      canvas.style.cursor = 'pointer';
      break;
    }
  }
  if (hoveredPoint === null) canvas.style.cursor = 'default';
});

canvas.addEventListener('mouseleave', () => {
  hoveredPoint = null;
});

drawAxes(t);
requestAnimationFrame(animate);
</script>
</body>
</html>
