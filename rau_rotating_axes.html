<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Connecting Geometric Rotations to Matrix Representations</title>
  <style>
    body {
      background: #f8f9fa;
      color: #222;
      font-family: 'Georgia', serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .container {
      max-width: 1200px;
      width: 100%;
    }
    
    h1 {
      text-align: center;
      font-size: 28px;
      margin-bottom: 10px;
    }
    
    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
      font-style: italic;
    }
    
    .main-content {
      display: grid;
      grid-template-columns: 500px 1fr;
      gap: 30px;
      align-items: start;
    }
    
    .canvas-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    canvas {
      border: 2px solid #ddd;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      cursor: default;
    }
    
    .controls {
      margin-top: 20px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 100%;
    }
    
    label { 
      margin: 0 10px;
      display: inline-block;
      font-family: monospace;
    }
    
    input[type="range"] {
      width: 150px;
    }
    
    .matrix-panel {
      background: white;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .matrix-section {
      margin-bottom: 25px;
    }
    
    .matrix-section h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #2c3e50;
      font-size: 18px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
    }
    
    .matrix {
      display: inline-grid;
      grid-template-columns: auto auto;
      gap: 10px 15px;
      padding: 15px 25px;
      border-left: 2px solid #333;
      border-right: 2px solid #333;
      margin: 10px;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      position: relative;
    }
    
    .matrix::before,
    .matrix::after {
      content: '';
      position: absolute;
      width: 8px;
      height: 2px;
      background: #333;
    }
    
    .matrix::before {
      top: 0;
      left: 0;
    }
    
    .matrix::after {
      bottom: 0;
      right: 0;
    }
    
    .matrix-label {
      font-weight: bold;
      margin-right: 10px;
      font-style: italic;
    }
    
    .matrix-value {
      text-align: right;
      font-weight: bold;
    }
    
    .matrix-value.cos-val {
      color: #e74c3c;
    }
    
    .matrix-value.sin-val {
      color: #3498db;
    }
    
    .matrix-value.neg {
      color: #95a5a6;
    }
    
    .formula {
      background: #ecf0f1;
      padding: 15px;
      border-radius: 5px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    
    .explanation {
      margin-top: 10px;
      padding: 10px;
      background: #fff9e6;
      border-left: 4px solid #f39c12;
      border-radius: 3px;
      font-size: 14px;
      line-height: 1.6;
    }
    
    .vector-notation {
      margin-top: 15px;
    }
    
    .vector {
      display: inline-grid;
      grid-template-columns: auto;
      gap: 8px;
      padding: 10px 20px;
      border-left: 2px solid #333;
      border-right: 2px solid #333;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      margin: 0 10px;
    }
    
    .identity-matrix {
      color: #27ae60;
    }
    
    .rotation-matrix {
      color: #9b59b6;
    }
    
    @media (max-width: 900px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>

<div class="container">
  <h1><a href="https://cello-phane.github.io/radicaltrig/rotations_in_cartesian_plane.html">Connecting Geometric Rotations to Matrix Representations</a></h1>
	 
  <div class="main-content">
    <div class="canvas-section">
      <canvas id="canvas" width="600" height="600"></canvas>
      <div class="controls">
        <label>Phase:
          <input type="range" id="slider" min="0" max="1" step="0.0001" value="1">
        </label>
        <label><input type="checkbox" id="auto"> Auto</label>
        <label>Speed:
          <input type="range" id="speed" min="0.1" max="2" step="0.1" value="0.1">
        </label>
      </div>
      
      <div class="matrix-section" id="relationship-section" style="display: none;">
        <div id="relationship-info" class="explanation" style="font-family: 'monospace'; font-size: 16px;">
        </div>
      </div>
    </div>
    
    <div class="matrix-panel">
      <div class="matrix-section">
        <h3>Current Rotation Matrix R(θ)</h3>
        <div>
          <span class="matrix-label">R(θ) =</span>
          <div class="matrix" id="rotation-matrix">
            <span class="matrix-value cos-val" id="r11">1.000</span>
            <span class="matrix-value sin-val" id="r12">0.000</span>
            <span class="matrix-value sin-val" id="r21">0.000</span>
            <span class="matrix-value cos-val" id="r22">1.000</span>
          </div>
        </div>
        <div class="formula" id="matrix-formula">
          R(θ) = cos(θ)·<span class="identity-matrix">I</span> + sin(θ)·<span class="rotation-matrix">Ī</span>
        </div>
      </div>
      
      <div class="matrix-section">
        <h3>Matrix Components</h3>
        <div>
          <span class="matrix-label identity-matrix">I</span> (Identity) =
          <div class="matrix">
            <span>1</span><span>0</span>
            <span>0</span><span>1</span>
          </div>
        </div>
        <div style="margin-top: 15px;">
          <span class="matrix-label rotation-matrix">Ī</span> (90° Rotation) =
          <div class="matrix">
            <span>0</span><span>-1</span>
            <span>1</span><span>0</span>
          </div>
        </div>
      </div>
      
      <div class="matrix-section">
        <h3>Vector Transformation</h3>
        <div class="vector-notation">
          <span class="matrix-label">v̄ =</span>
          <div class="vector">
            <span class="matrix-value cos-val" id="v1">a</span>
            <span class="matrix-value sin-val" id="v2">b</span>
          </div>
          <span style="font-size: 20px; margin: 0 10px;">→</span>
          <span class="matrix-label">v̄' =</span>
          <div class="vector">
            <span class="matrix-value" id="v1-prime">a'</span>
            <span class="matrix-value" id="v2-prime">b'</span>
          </div>
        </div>
        <div class="explanation" id="transform-explanation">
          Apply R(θ) to vector v̄ to rotate it by angle θ.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const slider = document.getElementById('slider');
const auto = document.getElementById('auto');
const speedSlider = document.getElementById('speed');

let t = 0, lastTime = 0;
let selectedPoint = null;
let hoveredPoint = null;
const points = [];

function getRAUComponents(t) {
  const tt = Math.max(0, Math.min(0.999999, t));
  const denom = 1.0 / Math.sqrt(1.0 - 2.0*tt + 2.0*tt*tt);
  const rcos = (1.0 - tt) * denom;
  const rsin = tt * denom;
  return { rcos, rsin };
}

function getRotationComponents(param) {
  let p = param;
  if (!isFinite(p)) p = 0;
  if (p < 0) p = 0;
  const q = Math.floor(p) % 4;
  const frac = p - Math.floor(p);
  const { rcos: c, rsin: s } = getRAUComponents(frac);
  
  const q0 = Number(q === 0);
  const q1 = Number(q === 1);
  const q2 = Number(q === 2);
  const q3 = Number(q === 3);
  let cos_result = c*q0 - s*q1 - c*q2 + s*q3;
  let sin_result = (s*q0 + c*q1 - s*q2 - c*q3) * Math.sign(param); 
  return { cos: cos_result, sin: sin_result };
}

function updateMatrixDisplay(cos, sin) {
  document.getElementById('r11').textContent = cos.toFixed(3);
  document.getElementById('r12').textContent = (-sin).toFixed(3);
  document.getElementById('r21').textContent = sin.toFixed(3);
  document.getElementById('r22').textContent = cos.toFixed(3);
  
  const theta = Math.atan2(sin, cos) * 180 / Math.PI;
  document.getElementById('matrix-formula').innerHTML = 
    `R(${theta.toFixed(1)}°) = ${cos.toFixed(3)}·<span class="identity-matrix">I</span> + ${sin.toFixed(3)}·<span class="rotation-matrix">Ī</span>`;
}

function updateVectorDisplay(cos, sin) {
  document.getElementById('v1').textContent = 'a';
  document.getElementById('v2').textContent = 'b';
  document.getElementById('v1-prime').textContent = `a·${cos.toFixed(2)} - b·${sin.toFixed(2)}`;
  document.getElementById('v2-prime').textContent = `a·${sin.toFixed(2)} + b·${cos.toFixed(2)}`;
  
  document.getElementById('transform-explanation').innerHTML = 
    `<strong>v̄' = R(θ)·v̄</strong><br>
    The rotation matrix transforms (a,b) to:<br>
    a' = a·cos(θ) - b·sin(θ)<br>
    b' = a·sin(θ) + b·cos(θ)`;
}

function generateRAUPoints(cx, cy, radius, cos, sin) {
  const offsets = [
    [ 1,  1, "#e74c3c", 0, "X"],
    [-1, -1, "#e74c3c", 1, "X"],
    [ 1, -1, "#3498db", 2, "Y"],
    [-1,  1, "#3498db", 3, "Y"],
  ];

  return offsets.map(([cMul, sMul, color, id, axis]) => {
    const x = cx + cMul * (axis === "X" ? cos : sin) * radius;
    const y = cy - sMul * (axis === "X" ? sin : cos) * radius;

    const cosVal = (axis === "X" ? cMul * cos : cMul * sin).toFixed(3);
    const sinVal = (axis === "X" ? sMul * sin : sMul * cos).toFixed(3);

    return { x, y, color, cosVal, sinVal, id, axis };
  });
}
  
function calculateRelationship(p1, p2) {
  const rauP1 = p1.id;
  const rauP2 = p2.id;
  
  const sameAxis = (rauP1 < 2 && rauP2 < 2) || (rauP1 >= 2 && rauP2 >= 2);
  const shift = sameAxis ? 2 : 1;
  
  const ccwPairs = [[0,2], [2,1], [1,3], [3,0]];
  const isClockwise = ccwPairs.some(pair => pair[0] === rauP1 && pair[1] === rauP2);
  const direction = isClockwise ? "clockwise" : "counter-clockwise";
  
  const cos1 = parseFloat(p1.cosVal);
  const sin1 = parseFloat(p1.sinVal);
  const cos2 = parseFloat(p2.cosVal);
  const sin2 = parseFloat(p2.sinVal);
  
  let transform = "";
  let matrixDesc = "";
  
  if (Math.abs(cos1 - cos2) < 0.01 && Math.abs(sin1 + sin2) < 0.01) {
    transform = `cos stays ${cos1.toFixed(2)} <br> sin → -sin`;
    matrixDesc = "Reflection across x-axis";
  } else if (Math.abs(cos1 + cos2) < 0.01 && Math.abs(sin1 - sin2) < 0.01) {
    transform = `cos → -cos <br> sin stays ${sin1.toFixed(2)}`;
    matrixDesc = "Reflection across y-axis";
  } else if (Math.abs(cos1 - sin2) < 0.01 && Math.abs(sin1 - cos2) < 0.01) {
    transform = `cos → sin <br> sin → cos`;
    matrixDesc = "90° rotation + axis swap";
  } else if (Math.abs(cos1 + sin2) < 0.01 && Math.abs(sin1 + cos2) < 0.01) {
    transform = `cos → -sin <br> sin → -cos`;
    matrixDesc = "270° rotation";
  } else if (Math.abs(cos1 + cos2) < 0.01 && Math.abs(sin1 + sin2) < 0.01) {
    transform = `cos → -cos <br> sin → -sin`;
    matrixDesc = "180° rotation";
  } else {
    transform = `cos: ${cos1.toFixed(3)} → ${cos2.toFixed(3)}
    			<br> sin:  ${sin1.toFixed(3)} → ${sin2.toFixed(3)}`;
    matrixDesc = `${(shift * 90)}° ${direction} rotation`;
  }
  
  return { 
    rauP1: rauP1.toFixed(1), 
    rauP2: rauP2.toFixed(1),
    shift: shift,
    direction,
    transform,
    matrixDesc
  };
}

function updateRelationshipDisplay(rel) {
  const section = document.getElementById('relationship-section');
  const info = document.getElementById('relationship-info');
  
  if (rel) {
    section.style.display = 'block';
    info.innerHTML = `
      <strong>Geometric:</strong> ${rel.shift} quadrant(s) ${rel.direction}<br>
      <strong>Matrix:</strong> ${rel.matrixDesc}<br>
      ${rel.transform}<br>
    `;
  } else {
    section.style.display = 'none';
  } //Hide on mouseleave from the point
}

function drawAxes(param) {
  const W = canvas.width, H = canvas.height;
  const cx = W / 2, cy = H / 2, radius = 150;

  ctx.clearRect(0, 0, W, H);

  ctx.strokeStyle = "#f0f0f0";
  ctx.lineWidth = 1;
  for (let i = -4; i <= 4; i++) {
    ctx.beginPath();
    ctx.moveTo(0, cy + i * 40);
    ctx.lineTo(W, cy + i * 40);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(cx + i * 40, 0);
    ctx.lineTo(cx + i * 40, H);
    ctx.stroke();
  }

  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.stroke();

  const { cos, sin } = getRotationComponents(param % 4);
  
  updateMatrixDisplay(cos, sin);
  updateVectorDisplay(cos, sin);

  points.length = 0;
  points.push(...generateRAUPoints(cx, cy, radius, cos, sin));

  const axes = { "X": [], "Y": [] };
  points.forEach(p => axes[p.axis].push(p));

  for (const axis in axes) {
    const [p1, p2] = axes[axis];
    ctx.strokeStyle = p1.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }

  //if (selectedPoint !== null && hoveredPoint !== null && selectedPoint !== hoveredPoint) {
  if (selectedPoint !== null && hoveredPoint !== null) {
    ctx.strokeStyle = "rgba(100,100,100,0.5)";
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(points[selectedPoint].x, points[selectedPoint].y);
    ctx.lineTo(points[hoveredPoint].x, points[hoveredPoint].y);
    ctx.stroke();
    ctx.setLineDash([]);
    
    const rel = calculateRelationship(points[selectedPoint], points[hoveredPoint]);
    updateRelationshipDisplay(rel);
  }
  /*} else {
    updateRelationshipDisplay(null);
  }*/

  points.forEach((p, idx) => {
    const isSelected = selectedPoint === idx;
    const isHovered = hoveredPoint === idx;

    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, isSelected ? 10 : isHovered ? 8 : 6, 0, Math.PI * 2);
    ctx.fill();

    if (isSelected) {
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });

  const labelOffset = 50;

  points.forEach(p => {
    const dx = p.x - cx;
    const dy = p.y - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const dirX = dx / dist;
    const dirY = dy / dist;
    const labelX = p.x + dirX * labelOffset;
    const labelY = p.y + dirY * labelOffset;

    let cosColor = "#e74c3c";
    let sinColor = "#3498db";

    if (selectedPoint !== null && hoveredPoint !== null && selectedPoint !== hoveredPoint) {
      const sel = points[selectedPoint];
      const hov = points[hoveredPoint];
      const cosP = parseFloat(p.cosVal);
      const sinP = parseFloat(p.sinVal);
      const cosSel = parseFloat(sel.cosVal);
      const sinSel = parseFloat(sel.sinVal);
      const cosHov = parseFloat(hov.cosVal);
      const sinHov = parseFloat(hov.sinVal);

      if (p.id === selectedPoint) {
        if (Math.abs(Math.abs(cosP) - Math.abs(cosHov)) < 0.01) {
          cosColor = "#27ae60";
        } else if (Math.abs(Math.abs(cosP) - Math.abs(sinHov)) < 0.01) {
          cosColor = "#9b59b6";
        }
        
        if (Math.abs(Math.abs(sinP) - Math.abs(sinHov)) < 0.01) {
          sinColor = "#27ae60";
        } else if (Math.abs(Math.abs(sinP) - Math.abs(cosHov)) < 0.01) {
          sinColor = "#f39c12";
        }
      } else if (p.id === hoveredPoint) {
        if (Math.abs(Math.abs(cosP) - Math.abs(cosSel)) < 0.01) {
          cosColor = "#27ae60";
        } else if (Math.abs(Math.abs(cosP) - Math.abs(sinSel)) < 0.01) {
          cosColor = "#9b59b6";
        }
        
        if (Math.abs(Math.abs(sinP) - Math.abs(sinSel)) < 0.01) {
          sinColor = "#27ae60";
        } else if (Math.abs(Math.abs(sinP) - Math.abs(cosSel)) < 0.01) {
          sinColor = "#f39c12";
        }
      }
    }

    ctx.font = "bold 12px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = cosColor;
    ctx.fillText(`cos: ${p.cosVal}`, labelX, labelY - 8);

    ctx.fillStyle = sinColor;
    ctx.fillText(`sin: ${p.sinVal}`, labelX, labelY + 8);
  });

  ctx.fillStyle = "#999";
  ctx.beginPath();
  ctx.arc(cx, cy, 3, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#000";
  ctx.font = "14px monospace";
  ctx.textAlign = "left";
  ctx.fillText(`RAU param: ${param.toFixed(3)}`, 15, 25);
}

function animate(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  if (auto.checked) {
    const speed = parseFloat(speedSlider.value);
    t = (t + dt * speed) % 1;
    slider.value = t;
  }

  drawAxes(t);
  requestAnimationFrame(animate);
}

slider.addEventListener('input', () => {
  t = parseFloat(slider.value);
  drawAxes(t);
});

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  for (let i = 0; i < points.length; i++) {
    const dx = mouseX - points[i].x;
    const dy = mouseY - points[i].y;
    if (Math.sqrt(dx * dx + dy * dy) < 15) {
      selectedPoint = selectedPoint === i ? null : i;
      break;
    }
  }
});

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  //hoveredPoint = null;
  for (let i = 0; i < points.length; i++) {
    const dx = mouseX - points[i].x;
    const dy = mouseY - points[i].y;
    if (Math.sqrt(dx * dx + dy * dy) < 15) {
      hoveredPoint = i;
      canvas.style.cursor = 'pointer';
      break;
    }
  }

  if (hoveredPoint === null) canvas.style.cursor = 'default';
});

canvas.addEventListener('mousedown', () => hoveredPoint = selectedPoint);

drawAxes(t);
requestAnimationFrame(animate);
</script>

</body>
</html>
