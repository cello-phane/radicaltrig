<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RAU Axis Reflection with Endpoint Labels</title>
<style>
  body {
    background: #fff;
    color: #222;
    text-align: center;
    font-family: monospace;
    margin: 0;
    padding: 10px;
  }
  canvas {
    border: 1px solid #ccc;
    margin-top: 10px;
    border-radius: 8px;
    background: #fff;
  }
  label { margin: 0 8px; }
</style>
</head>
<body>
<h2>RAU Axis Reflection — Symmetry Mapping</h2>
<canvas id="canvas" width="500" height="500"></canvas>
<br>
<label>Phase:
  <input type="range" id="slider" min="0" max="4" step="0.0005" value="0">
</label>
<label><input type="checkbox" id="auto" unchecked> Auto</label>
<label>Speed:
  <input type="range" id="speed" min="0.1" max="2" step="0.1" value="0.1">
</label>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const slider = document.getElementById('slider');
const auto = document.getElementById('auto');
const speedSlider = document.getElementById('speed');

let t = 0, lastTime = 0;
let selectedPoint = null;
let hoveredPoint = null;
const points = [];

function getRAUComponents(f) {
  const a = 1 - 2*f + 2*f*f;
  const denom = 1 / Math.sqrt(a);
  const c = (1 - f) * denom;
  const s = f * denom;
  return { c, s };
}

function getRotationComponents(param) {
  if (typeof param !== "number") param = 0;

  const absVal = Math.abs(param);
  const quadrant = Math.floor(absVal) % 4;
  const fraction = absVal - quadrant;

  // RAU components
  const { c: rauC, s: rauS } = getRAUComponents(fraction);
  let c = rauC;
  let s = rauS;

  // Quadrant rotation
  switch (quadrant) {
    case 0:
      break; // c,s stay
    case 1:
      [c, s] = [-s, c];
      break;
    case 2:
      [c, s] = [-c, -s];
      break;
    case 3:
      [c, s] = [s, -c];
      break;
  }

  // Preserve sign of original param
  s *= Math.sign(param);

  return { c, s, quadrant };
}

function generateRAUPoints(cx, cy, radius, cos, sin) {
  // offsets: [cosMultiplier, sinMultiplier, color, id, axisType]
  const offsets = [
    [ 1, -1, "#e74c3c", 0, "X"], // X+ endpoint
    [-1,  1, "#e74c3c", 1, "X"], // X- endpoint
    [ 1,  1, "#3498db", 2, "Y"], // Y+ endpoint
    [-1, -1, "#3498db", 3, "Y"], // Y- endpoint
  ];

  return offsets.map(([cMul, sMul, color, id, axis]) => {
    // Coordinates using signed multipliers
    const x = cx + cMul * (axis === "X" ? cos : sin) * radius;
    const y = cy + sMul * (axis === "X" ? sin : cos) * radius;

    const cosVal = (axis === "X" ? cMul * cos : cMul * sin).toFixed(3);
    const sinVal = (axis === "X" ? sMul * sin : sMul * cos).toFixed(3);

    return { x, y, color, cosVal, sinVal, id, axis };
  });
}
  
function calculateRelationship(p1, p2) {
  // RAU parameters for each point (0-4 range)
  const rauP1 = p1.id;
  const rauP2 = p2.id;
  
  // Calculate shift needed (accounting for circular nature 0-4)
  let shift = (rauP2 - rauP1) % 4;
  if (shift < 0) shift += 4;
  
  const direction = shift === 0 ? "same" : shift <= 2 ? "counter-clockwise" : "clockwise";
  const amount = shift === 0 ? 0 : shift <= 2 ? shift : 4 - shift;
  
  // Describe the coordinate transformation
  const cos1 = parseFloat(p1.cosVal);
  const sin1 = parseFloat(p1.sinVal);
  const cos2 = parseFloat(p2.cosVal);
  const sin2 = parseFloat(p2.sinVal);
  
  let transform = "";
  
  // Check for common transformations
  if (Math.abs(cos1 - cos2) < 0.01 && Math.abs(sin1 + sin2) < 0.01) {
    transform = `cos stays ${cos1.toFixed(2)}, sin → -sin`;
  } else if (Math.abs(cos1 + cos2) < 0.01 && Math.abs(sin1 - sin2) < 0.01) {
    transform = `cos → -cos, sin stays ${sin1.toFixed(2)}`;
  } else if (Math.abs(cos1 - sin2) < 0.01 && Math.abs(sin1 - cos2) < 0.01) {
    transform = `cos → sin, sin → cos`;
  } else if (Math.abs(cos1 + sin2) < 0.01 && Math.abs(sin1 + cos2) < 0.01) {
    transform = `cos → -sin, sin → -cos`;
  } else if (Math.abs(cos1 + cos2) < 0.01 && Math.abs(sin1 + sin2) < 0.01) {
    transform = `cos → -cos, sin → -sin`;
  } else if (Math.abs(cos1 - sin2) < 0.01 && Math.abs(sin1 + cos2) < 0.01) {
    transform = `cos → sin, sin → -cos`;
  } else {
    transform = `(cos: ${cos1.toFixed(2)} → ${cos2.toFixed(2)}, sin: ${sin1.toFixed(2)} → ${sin2.toFixed(2)})`;
  }
  
  return { 
    rauP1: rauP1.toFixed(1), 
    rauP2: rauP2.toFixed(1),
    shift: amount,
    direction,
    transform
  };
}

function drawAxes(param) {
  const W = canvas.width, H = canvas.height;
  const cx = W / 2, cy = H / 2, radius = 150;

  ctx.clearRect(0, 0, W, H);

  // --- Grid ---
  ctx.strokeStyle = "#f0f0f0";
  ctx.lineWidth = 1;
  for (let i = -4; i <= 4; i++) {
    ctx.beginPath();
    ctx.moveTo(0, cy + i * 40);
    ctx.lineTo(W, cy + i * 40);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(cx + i * 40, 0);
    ctx.lineTo(cx + i * 40, H);
    ctx.stroke();
  }

  // --- Circle ---
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.stroke();

  // --- Rotation ---
  const { c, s } = getRotationComponents(param % 4);
  const cos = typeof c === "number" ? c : 0;
  const sin = typeof s === "number" ? s : 0;

  // --- Generate points ---
  points.length = 0;
  points.push(...generateRAUPoints(cx, cy, radius, cos, sin));

  // --- Draw axes dynamically ---
  const axes = { "X": [], "Y": [] };
  points.forEach(p => axes[p.axis].push(p));

  for (const axis in axes) {
    const [p1, p2] = axes[axis];
    ctx.strokeStyle = p1.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }

  // --- Connection line ---
  if (selectedPoint !== null && hoveredPoint !== null && selectedPoint !== hoveredPoint) {
    ctx.strokeStyle = "rgba(100,100,100,0.5)";
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(points[selectedPoint].x, points[selectedPoint].y);
    ctx.lineTo(points[hoveredPoint].x, points[hoveredPoint].y);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // --- Draw points ---
  points.forEach((p, idx) => {
    const isSelected = selectedPoint === idx;
    const isHovered = hoveredPoint === idx;

    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, isSelected ? 10 : isHovered ? 8 : 6, 0, Math.PI * 2);
    ctx.fill();

    if (isSelected) {
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });

  // --- Labels with hover/selection coloring ---
  const labelOffset = 50;
  function mapColor(val1, val2, matchColor = "#27ae60", altColor = "#f39c12") {
    if (Math.abs(Math.abs(val1) - Math.abs(val2)) < 0.01) return matchColor;
    return null;
  }

  points.forEach(p => {
    const dx = p.x - cx;
    const dy = p.y - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const dirX = dx / dist;
    const dirY = dy / dist;
    const labelX = p.x + dirX * labelOffset;
    const labelY = p.y + dirY * labelOffset;

    let cosColor = p.color;
    let sinColor = p.axis === "X" ? "#3498db" : "#e74c3c";

    if (selectedPoint !== null && hoveredPoint !== null && selectedPoint !== hoveredPoint) {
      const sel = points[selectedPoint];
      const hov = points[hoveredPoint];

      const cosP = parseFloat(p.cosVal);
      const sinP = parseFloat(p.sinVal);
      const cosSel = parseFloat(sel.cosVal);
      const sinSel = parseFloat(sel.sinVal);
      const cosHov = parseFloat(hov.cosVal);
      const sinHov = parseFloat(hov.sinVal);

      if (p.id === selectedPoint) {
        cosColor = mapColor(cosP, cosHov) || mapColor(cosP, sinHov) || cosColor;
        sinColor = mapColor(sinP, sinHov) || mapColor(sinP, cosHov, "#f39c12") || sinColor;
      } else if (p.id === hoveredPoint) {
        cosColor = mapColor(cosP, cosSel) || mapColor(cosP, sinSel) || cosColor;
        sinColor = mapColor(sinP, sinSel) || mapColor(sinP, cosSel, "#f39c12") || sinColor;
      }
    }

    ctx.font = "bold 12px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = cosColor;
    ctx.fillText(`cos: ${p.cosVal}`, labelX, labelY - 8);

    ctx.fillStyle = sinColor;
    ctx.fillText(`sin: ${p.sinVal}`, labelX, labelY + 8);
  });

  // --- Center ---
  ctx.fillStyle = "#999";
  ctx.beginPath();
  ctx.arc(cx, cy, 3, 0, Math.PI * 2);
  ctx.fill();

  // --- Info ---
  ctx.fillStyle = "#000";
  ctx.font = "14px monospace";
  ctx.textAlign = "left";
  ctx.fillText(`RAU param: ${param.toFixed(3)}`, 15, 25);

  if (selectedPoint !== null && hoveredPoint !== null && selectedPoint !== hoveredPoint) {
    const rel = calculateRelationship(points[selectedPoint], points[hoveredPoint]);
    ctx.font = "12px monospace";
    ctx.fillStyle = "#333";
    ctx.fillText(`RAU Point ${rel.rauP1} → RAU Point ${rel.rauP2}`, 15, 45);
    ctx.fillText(`Shift: ${rel.shift} quadrant(s) ${rel.direction}`, 15, 60);
    ctx.fillText(`Transform: ${rel.transform}`, 15, 75);
  }
}


function animate(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  
  if (auto.checked) {
    const speed = parseFloat(speedSlider.value);
    t = (t + dt * 0.5 * speed) % 4;
    slider.value = t;
  }
  
  drawAxes(t);
  requestAnimationFrame(animate);
}

slider.addEventListener('input', () => {
  t = parseFloat(slider.value);
  drawAxes(t);
});

// Mouse click to select point
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  for (let i = 0; i < points.length; i++) {
    const dx = mouseX - points[i].x;
    const dy = mouseY - points[i].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 15) {
      selectedPoint = selectedPoint === i ? null : i;
      break;
    }
  }
});

// Mouse move to hover over points
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  hoveredPoint = null;
  for (let i = 0; i < points.length; i++) {
    const dx = mouseX - points[i].x;
    const dy = mouseY - points[i].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 15) {
      hoveredPoint = i;
      canvas.style.cursor = 'pointer';
      break;
    }
  }
  if (hoveredPoint === null) canvas.style.cursor = 'default';
});

canvas.addEventListener('mouseleave', () => {
  hoveredPoint = null;
});

drawAxes(t);
requestAnimationFrame(animate);
</script>
</body>
</html>
