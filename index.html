<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RAU System & Vector Visualization — Full</title>

<!-- MathJax -->
<script>
window.MathJax = {
  tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
  svg: { fontCache: 'global' }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script>
	function changeFontSize(changeAmount, id_name) {
		let element = document.getElementById(id_name);
		if (element) {
			let currentSize = parseInt(element.style.fontSize);
			let newSize = currentSize + changeAmount;
			if (newSize < 8) newSize = 8;
			element.style.fontSize = newSize + 'px';
			console.log(`Element with ID "${id_name}" font size changed.`);
		}
	}
</script>

<style>
  :root {
    --accent: #2196F3;
    --bg: #f0f0f0;
    --card: #ffffff;
    --muted: #888;
  }
  html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:var(--bg); color:#222; }
  header {
    background:#333; color:white; padding:10px 16px; display:flex; align-items:center; justify-content:space-between;
  }
  header h1 { margin:0; font-size:18px; }
  .top-controls { display:flex; gap:2px; align-items:center; }
  .toggle-btn {
    background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600;
  }
  .page {
    padding:16px;
  }

  /* sections */
  section {
    overflow:hidden;
    max-height:0;
    opacity:0;
    transition: max-height 0.6s ease, opacity 0.6s ease, padding 0.3s ease;
  }
  section.active {
    max-height:2400px;
    opacity:1;
    padding:20px 16px 40px;
  }

  /* general container card */
  .card {
    background:var(--card);
    border-radius:10px;
    padding:18px;
    max-width:1000px;
    margin:0 auto;
    box-shadow:0 6px 18px rgba(0,0,0,0.06);
  }

  /* RAU canvas */
  #canvas1 { border:2px solid #333; border-radius:8px; background:white; display:block; margin:16px auto; }

  /* formulas / small description */
  .desc { background:#e8f4f8; border-left:4px solid var(--accent); padding:12px; margin-top:12px; border-radius:6px; }
  .controls { margin-top:12px; text-align:center; }
  input[type=range] { width:320px; margin-top:8px; }

  /* vector section layout */
  .vector-grid {
    display:block;
    align-items:flex-start;
    margin-top:8px;
  }
  #canvas2 { border:2px solid #333; border-radius:8px; background:white; display:block; }
  .panel {
    min-width:260px;
    background:white;
    padding:12px;
    border-radius:8px;
    box-shadow:0 2px 8px rgba(0,0,0,0.06);
    font-size:16px;
  }
  .control-group { display:flex; align-items:center; gap:8px; margin:8px 0; }
  .control-group label { min-width:110px; font-weight:600; }
  .control-group input[type=range] { flex:1; }
  .value { width:56px; text-align:right; font-family:monospace; }

  pre#resultsContent { background:#f5f5f5; padding:10px; border-radius:6px; white-space:pre-wrap; }

  /* formula side panel (collapsible to slim bar) */
  #formulaPanel {
    position:fixed;
    right:8px;
    top:50px;
    width:420px;
    background:rgba(255,255,255,0.98);
    border:2px solid var(--accent);
    border-radius:10px;
    box-shadow:0 8px 24px rgba(0,0,0,0.12);
    transition: transform 0.45s cubic-bezier(.2,.9,.2,1), width 0.3s ease;
    z-index:1200;
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  #formulaPanel.slim {
    width:64px;
    transform: translateX(0);
  }
  #formulaHeader {
    background:var(--accent);
    color:white;
    padding:8px 10px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    cursor:pointer;
  }
  #formulaHeader .title { font-weight:700; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  #formulaHeader .chev { font-size:16px; opacity:0.95; }
  #formulaBody { padding:2px 4px; font-size:13px; background:transparent; }
  /* when slim, hide formula content but keep header visible */
  #formulaPanel.slim #formulaBody { display:none; }
  #formulaPanel.slim #formulaHeader { justify-content:left; }

  /* small responsive */
  @media (max-width:900px) {
    #formulaPanel { right:10px; top:32px; width:420px; }
    #formulaPanel.slim { width:56px; }
    .panel { width:420px; }
  }
  .conversion-panel {
    display: none;
    background: #fff;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    margin-top: 10px;
    text-align: center;
  }
  
  #conversionCanvas {
    display: block;
    margin: auto;
  }
	
</style>
</head>
<body>

<header>
  <h1>RAU Interactive Visualizations</h1>
  <div class="top-controls">
    <button id="toggleButton" class="toggle-btn">Switch to Vector Diagram</button>
  </div>
</header>

<!-- Floating MathJax formula panel (collapsible to slim bar) -->
<div id="formulaPanel" aria-hidden="false">
  <div id="formulaHeader" title="Click to expand/collapse RAU formulas (MathJax)">
    <div class="title">RAU Formulas</div>
    <div class="chev" id="formulaChevron">◀</div>
  </div>
  <div id="formulaBody">
    <p style="margin:0 0 8px 0; font-weight:600;">For parameter \(0.0 < t < 1.0\):</p>

    <div id="mathBlock">
      <!-- MathJax-rendered content -->
      <div>
        \[
        \mathrm{rsin}(t) \;=\; \frac{t}{\sqrt{\,1.0 - 2.0t + 2.0t^{2.0}\,}}
        \]
      </div>
      <div>
        \[
        \mathrm{rcos}(t) \;=\; \frac{1.0 - t}{\sqrt{\,1.0 - 2.0t + 2.0t^{2.0}\,}}
        \]
      </div>
      <div>
        \[
        \mathrm{rtan}(t) \;=\; \frac{t}{1.0 - t}
        \]
      </div>
    </div>
      <strong>Vector Information</strong>
	  <button onclick="changeFontSize(2,'resultsContent')">+</button>
      <button onclick="changeFontSize(-2,'resultsContent')">-</button>
      <pre id="resultsContent" style="margin:0; font-family:monospace; font-size:13px; background:#fafafa; padding:8px; border-radius:6px;"></pre>
      
   	<div class="control-group">
   	  <label>Conversion Reference</label>
   	  <input type="checkbox" id="showConversion" unchecked>
   	</div>
   
   	<div id="conversionPanel" class="conversion-panel">
   	  <canvas id="conversionCanvas" width="280" height="220"></canvas>
   	</div>
  </div>
</div>

<!-- RAU Section -->
<section id="section1" class="inactive">
  <div class="card">
    <h2 style="margin-top:6px;">RAU — Explanation</h2>
    <div class="desc">
      <strong>Key insight:</strong> RAU maps a linear parameter (0.0–4.0) to circular motion by using rational functions on quadrant diagonals.
    </div>

    <canvas id="canvas1" width="420" height="420" style="display:block;margin:18px auto;"></canvas>

    <div class="controls" style="text-align:center;">
      <label style="font-weight:700;">t Parameter: <span id="paramValue">0.00</span></label><br>
      <input type="range" id="paramSlider" min="0" max="4" step="0.01" value="0" />
    </div>

    <div style="margin-top:12px; background:#f5f5f5; padding:10px; border-radius:8px;">
      More information @ https://www.youtube.com/watch?v=TJr4YfEgVuk
    </div>
  </div>
</section>

<!-- Vector section -->
<section id="section2" class="active">
  <div class="card">
    <h2 style="margin-top:6px;">Vector + RAU Angle Visualization</h2>

    <div class="vector-grid">
      <canvas id="canvas2" width="760" height="560"></canvas>

      <div class="panel">
        <div class="control-group">
          <label for="uLength">u length:</label>
          <input id="uLength" type="range" min="50" max="200" value="120">
          <div class="value" id="uLengthVal">120</div>
        </div>

        <div class="control-group">
          <label for="uAngle">u angle (°):</label>
          <input id="uAngle" type="range" min="0" max="360" value="30">
          <div class="value" id="uAngleVal">30°</div>
        </div>

        <div class="control-group">
          <label for="vLength">v length:</label>
          <input id="vLength" type="range" min="50" max="200" value="100">
          <div class="value" id="vLengthVal">100</div>
        </div>

        <div class="control-group">
          <label for="vAngle">v angle (°):</label>
          <input id="vAngle" type="range" min="0" max="360" value="0">
          <div class="value" id="vAngleVal">0°</div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
/* ---------------------------
   Toggle between sections
   --------------------------- */
const toggleBtn = document.getElementById('toggleButton');
const s1 = document.getElementById('section1');
const s2 = document.getElementById('section2');
toggleBtn.addEventListener('click', () => {
  const showing1 = s1.classList.contains('active');
  s1.classList.toggle('active', !showing1);
  s2.classList.toggle('active', showing1);
  toggleBtn.textContent = showing1 ? 'Switch to RAU Explanation' : 'Switch to Vector Diagram';
});

/* ---------------------------
   MathJax formula panel logic
   - collapses to slim bar (still visible)
   - expand/collapse toggles MathJax typeset
   --------------------------- */
const formulaPanel = document.getElementById('formulaPanel');
const formulaHeader = document.getElementById('formulaHeader');
const formulaChevron = document.getElementById('formulaChevron');

let isSlim = false;
function setSlimMode(slim) {
  isSlim = !!slim;
  if (isSlim) {
    formulaPanel.classList.add('slim');
    formulaChevron.textContent = '▶';
  } else {
    formulaPanel.classList.remove('slim');
    formulaChevron.textContent = '◀';
    // typeset MathJax when opened to ensure rendering
    if (window.MathJax && MathJax.typesetPromise) {
      MathJax.typesetPromise().catch(console.error);
    }
  }
}
formulaHeader.addEventListener('click', () => {
  setSlimMode(!isSlim);
});
// start not slim (expanded) but you can click header to slim
setSlimMode(false);

/* ---------------------------
   RAU canvas (section 1)
   --------------------------- */
(function() {
  const canvas = document.getElementById('canvas1');
  const ctx = canvas.getContext('2d');
  const slider = document.getElementById('paramSlider');
  const valueDisplay = document.getElementById('paramValue');

  // rational components (matching provided formulas)
  function getRAUComponents(t) {
    // clamp t in [0,1)
    const tt = Math.max(0, Math.min(0.999999, t));
    const denom = 1.0 / Math.sqrt(1.0 - 2.0*tt + 2.0*tt*tt);
    const rcos = (1.0 - tt) * denom;
    const rsin = tt * denom;
    return { cos: rcos, sin: rsin };
  }

  function getRotationComponents(param) {
    // param is 0..4
    let p = param;
    if (!isFinite(p)) p = 0;
    if (p < 0) p = 0;
    const q = Math.floor(p) % 4;
    const frac = p - Math.floor(p);
    const { cos: c, sin: s } = getRAUComponents(frac);
    let cos_val, sin_val;
    switch (q) {
      case 0: cos_val = c; sin_val = s; break;
      case 1: cos_val = -s; sin_val = c; break;
      case 2: cos_val = -c; sin_val = -s; break;
      case 3: cos_val = s; sin_val = -c; break;
    }
    return { cos: cos_val, sin: sin_val, quadrant: q, fraction: frac };
  }

  // draw helpers
  function drawGrid(cx, cy, w, h, scale=50) {
    ctx.save();
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;
    for (let i = -Math.floor(w/scale); i <= Math.floor(w/scale); i++) {
      ctx.beginPath();
      ctx.moveTo(cx + i*scale, 0);
      ctx.lineTo(cx + i*scale, h);
      ctx.stroke();
    }
    for (let j = -Math.floor(h/scale); j <= Math.floor(h/scale); j++) {
      ctx.beginPath();
      ctx.moveTo(0, cy + j*scale);
      ctx.lineTo(w, cy + j*scale);
      ctx.stroke();
    }
    // axes
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
    ctx.moveTo(0, cy); ctx.lineTo(w, cy);
    ctx.stroke();
    ctx.restore();
  }

  function draw() {
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    const cx = W/2, cy = H/2;
    drawGrid(cx, cy, W, H, 40);

    // circle
    const radius = Math.min(W,H) * 0.34;
    ctx.save();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // diagonals for quadrants
    ctx.save();
    ctx.setLineDash([6,6]);
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    // Q0 diag: right -> top
    ctx.beginPath();
    ctx.moveTo(cx + radius, cy);
    ctx.lineTo(cx, cy - radius);
    ctx.moveTo(cx, cy - radius);
    ctx.lineTo(cx - radius, cy);
    ctx.moveTo(cx - radius, cy);
    ctx.lineTo(cx, cy + radius);
    ctx.moveTo(cx, cy + radius);
    ctx.lineTo(cx + radius, cy);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    // draw RAU point and line
    const param = parseFloat(slider.value);
    const info = getRotationComponents(param);

    const x = cx + info.cos * radius;
    const y = cy - info.sin * radius;

    // highlight diagonal for current quadrant
    ctx.save();
    ctx.strokeStyle = '#00aa00';
    ctx.lineWidth = 3;
    ctx.beginPath();
    switch (info.quadrant) {
      case 0: ctx.moveTo(cx + radius, cy); ctx.lineTo(cx, cy - radius); break;
      case 1: ctx.moveTo(cx, cy - radius); ctx.lineTo(cx - radius, cy); break;
      case 2: ctx.moveTo(cx - radius, cy); ctx.lineTo(cx, cy + radius); break;
      case 3: ctx.moveTo(cx, cy + radius); ctx.lineTo(cx + radius, cy); break;
    }
    ctx.stroke();
    ctx.restore();

    // radius line
    ctx.save();
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x, y);
    ctx.stroke();

    // point
    ctx.fillStyle = '#ff4444';
    ctx.beginPath();
    ctx.arc(x, y, 7, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // small info text
    ctx.fillStyle = '#222';
    ctx.font = '13px monospace';
    ctx.fillText('Quadrant: ' + info.quadrant, 12, 20);
    ctx.fillText('Fraction: ' + info.fraction.toFixed(3), 12, 38);
    ctx.fillText('rsin: ' + (info.sin).toFixed(4), 12, 56);
    ctx.fillText('rcos: ' + (info.cos).toFixed(4), 12, 74);

    valueDisplay.textContent = param.toFixed(2);
  }

  slider.addEventListener('input', draw);
  draw();

  // ensure MathJax renders formulas initially
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise().catch(console.error);
  }
})();

/* ---------------------------
   Vector diagram
   --------------------------- */
(function() {
  const canvas = document.getElementById('canvas2');
const ctx = canvas.getContext('2d');
  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  
  const controls = {
      uLength: document.getElementById('uLength'),
      uAngle: document.getElementById('uAngle'),
      vLength: document.getElementById('vLength'),
      vAngle: document.getElementById('vAngle')
  };
  const displays = {
      uLengthVal: document.getElementById('uLengthVal'),
      uAngleVal: document.getElementById('uAngleVal'),
      vLengthVal: document.getElementById('vLengthVal'),
      vAngleVal: document.getElementById('vAngleVal'),
      resultsContent: document.getElementById('resultsContent')
  };
  
  function degToRad(deg) { return deg * Math.PI/180; }
  function radToDeg(rad) { return rad*180/Math.PI; }
  
  function drawArrow(ctx, fromX, fromY, toX, toY, color, width=2){
      const headLen=12;
      const dx=toX-fromX, dy=toY-fromY;
      const angle=Math.atan2(dy,dx);
      ctx.strokeStyle=color;
      ctx.lineWidth=width;
      ctx.beginPath();
      ctx.moveTo(fromX,fromY);
      ctx.lineTo(toX,toY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toX,toY);
      ctx.lineTo(toX-headLen*Math.cos(angle-Math.PI/6),toY-headLen*Math.sin(angle-Math.PI/6));
      ctx.moveTo(toX,toY);
      ctx.lineTo(toX-headLen*Math.cos(angle+Math.PI/6),toY-headLen*Math.sin(angle+Math.PI/6));
      ctx.stroke();
  }
  
  function drawText(ctx,text,x,y,color='black',font='14px Arial'){
      ctx.fillStyle=color;
      ctx.font=font;
      ctx.fillText(text,x,y);
  }
  
  function drawGrid(ctx,width,height,scale=50){
      ctx.strokeStyle='#ddd';
      ctx.lineWidth=1;
      for(let i=-Math.floor(width/scale);i<=Math.floor(width/scale);i++){
          ctx.beginPath();
          ctx.moveTo(centerX+i*scale,0);
          ctx.lineTo(centerX+i*scale,height);
          ctx.stroke();
      }
      for(let j=-Math.floor(height/scale);j<=Math.floor(height/scale);j++){
          ctx.beginPath();
          ctx.moveTo(0,centerY+j*scale);
          ctx.lineTo(width,centerY+j*scale);
          ctx.stroke();
      }
      // axes
      ctx.strokeStyle='#666';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(centerX,0); ctx.lineTo(centerX,height);
      ctx.moveTo(0,centerY); ctx.lineTo(width,centerY);
      ctx.stroke();
  }
  
  function shadeQuadrant(ctx,uEnd,vEnd){
      ctx.fillStyle='rgba(200,200,255,0.1)';
      ctx.beginPath();
      ctx.moveTo(centerX,centerY);
      ctx.lineTo(uEnd.x,uEnd.y);
      ctx.lineTo(vEnd.x,vEnd.y);
      ctx.closePath();
      ctx.fill();
  }
  
  // --- RAU radical sine & cosine ---
  function radicalSine(t){
      t = t % 4;
      const quadrant = Math.floor(t);
      const lt = t - quadrant;
      const a = 1 - 2*lt + 2*lt*lt;
      switch(quadrant){
          case 0: return lt/Math.sqrt(a);
          case 1: return (1-lt)/Math.sqrt(a);
          case 2: return -lt/Math.sqrt(a);
          case 3: return -(1-lt)/Math.sqrt(a);
      }
  }
  
  function radicalCosine(t){
      t = t % 4;
      const quadrant = Math.floor(t);
      const lt = t - quadrant;
      const a = 1 - 2*lt + 2*lt*lt;
      switch(quadrant){
          case 0: return (1-lt)/Math.sqrt(a);
          case 1: return -lt/Math.sqrt(a);
          case 2: return -(1-lt)/Math.sqrt(a);
          case 3: return lt/Math.sqrt(a);
      }
  }
	
  function radicalTangent(t){
      return 1-t===0 ? t/(1-t) : 0;
  }
	
  // Compute RAU phase from two vectors (0-4) 
  /* Using atan2 logic that is modified */
  function computeRAUPhase(u,v) {
	 const mix = (a, b, c) => c ? b : a;
	 const cross = u.x * v.y - u.y * v.x;
	 const dot = u.x * v.x + u.y * v.y;
	 let angle = Math.abs(cross) / (Math.abs(dot) + Math.abs(cross));
	 // Quadrant blending logic
	 const q4fix = mix(Math.sign(cross) * angle, 4.0 - angle, dot > 0 && cross < 0);
	 const qblend = mix(mix(q4fix, angle, cross > dot), angle + 1.0, cross < 0 && dot < 0);
	 const halfrot = mix(2.0 - angle, angle + 2.0, cross < 0);
	 return mix(qblend, halfrot, dot < 0);
  }
  
  // --- Compute traditional angle 0→2π ---
  function vectorAngle(u,v){
      const angle = Math.atan2(v.y,v.x) - Math.atan2(u.y,u.x);
      return (angle + 2*Math.PI) % (2*Math.PI);
  }
  
  function drawChordConnection(ctx, u, v, radius) {
      // Normalize vectors to unit circle
      const uNorm = {x: u.x / Math.sqrt(u.x*u.x + u.y*u.y), 
                     y: u.y / Math.sqrt(u.x*u.x + u.y*u.y)};
      const vNorm = {x: v.x / Math.sqrt(v.x*v.x + v.y*v.y), 
                     y: v.y / Math.sqrt(v.x*v.x + v.y*v.y)};
      
      // Draw theoretical circle
      ctx.strokeStyle = 'rgba(100, 200, 100, 0.3)';
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Triangle vertices
      const O = {x: centerX, y: centerY};
      const B = {x: centerX + radius * uNorm.x, y: centerY + radius * uNorm.y};
      const A = {x: centerX + radius * vNorm.x, y: centerY + radius * vNorm.y};
      
      // Midpoint M (for mirror line)
      const M = {x: (O.x + A.x) / 2, y: (O.y + A.y) / 2};
      
      // Draw triangle
      ctx.strokeStyle = 'rgba(0, 150, 0, 0.5)';
      ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(O.x, O.y);
      ctx.lineTo(B.x, B.y);
      ctx.lineTo(A.x, A.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Draw mirror line (vertical through M)
      ctx.strokeStyle = 'rgba(0, 150, 0, 0.3)';
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(M.x, M.y - 50);
      ctx.lineTo(M.x, M.y + 50);
      ctx.stroke();
      ctx.setLineDash([]);
  
      // label chord length
      const chordLen = Math.hypot(A.x - B.x, A.y - B.y);
      //drawText(ctx, `Chord = ${chordLen.toFixed(1)}`, (A.x+B.x)/2 + 10, (A.y+B.y)/2, '#060', '12px monospace');
      
      // mark the arc endpoints
      ctx.fillStyle = '#060';
      ctx.beginPath(); ctx.arc(A.x, A.y, 3, 0, 2*Math.PI); ctx.fill();
      ctx.beginPath(); ctx.arc(B.x, B.y, 3, 0, 2*Math.PI); ctx.fill();
  }
  
  function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
  
      drawGrid(ctx,canvas.width,canvas.height,50);
  
      const uLen = parseInt(controls.uLength.value);
      const uAng = degToRad(parseInt(controls.uAngle.value));
      const vLen = parseInt(controls.vLength.value);
      const vAng = degToRad(parseInt(controls.vAngle.value));
  
      displays.uLengthVal.textContent = uLen;
      displays.uAngleVal.textContent = radToDeg(uAng).toFixed(0)+'°';
      displays.vLengthVal.textContent = vLen;
      displays.vAngleVal.textContent = radToDeg(vAng).toFixed(0)+'°';
  
      const u={x:uLen*Math.cos(uAng), y:-uLen*Math.sin(uAng)};
      const v={x:vLen*Math.cos(vAng), y:-vLen*Math.sin(vAng)};
  
      const uEnd={x:centerX+u.x, y:centerY+u.y};
      const vEnd={x:centerX+v.x, y:centerY+v.y};
      const para={x:centerX+u.x+v.x, y:centerY+u.y+v.y};
  
      // lightly shade quadrant
      shadeQuadrant(ctx,uEnd,vEnd);
  
      // parallelogram
      ctx.strokeStyle='#aaa';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(centerX,centerY);
      ctx.lineTo(uEnd.x,uEnd.y);
      ctx.lineTo(para.x,para.y);
      ctx.lineTo(vEnd.x,vEnd.y);
      ctx.closePath();
      ctx.stroke();
  
      // vectors
      drawArrow(ctx,centerX,centerY,uEnd.x,uEnd.y,'#ff4444',3);
      drawArrow(ctx,centerX,centerY,vEnd.x,vEnd.y,'#4444ff',3);
  
      // angle arc
      const arcRadius = Math.min(uLen, vLen);
      const startAngle = Math.min(uAng,vAng);
      const endAngle = Math.max(uAng,vAng);
      ctx.strokeStyle='#666';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(centerX,centerY,arcRadius,-endAngle,-startAngle);
      ctx.stroke();
      const midAngle = (startAngle+endAngle)/2;
      const labelX=centerX+(arcRadius+15)*Math.cos(midAngle);
      const labelY=centerY-(arcRadius+15)*Math.sin(midAngle);
      drawText(ctx,'θ',labelX,labelY,'#666','bold 14px Arial');
  
      // cross, dot
      const cross = u.x*v.y - u.y*v.x;
      const dot = u.x*v.x + u.y*v.y;
  
      // traditional
      const angleRad = vectorAngle(u,v);
      const angleDeg = radToDeg(angleRad);
      const tangent = radicalTangent(u,v);
  
      // rau
      const rauPhase = computeRAUPhase(u,v);
      const rauSine = radicalSine(rauPhase);
      const rauCos = radicalCosine(rauPhase);
      //const rauRad = Math.atan(Math.abs(cross/dot));
	  const rauRad = computeRAUPhase(u,v) * (Math.PI / 2);
      const rauDeg = radToDeg(rauRad);
  
      function formatNum(num, width=8, decimals=2){
          return num.toFixed(decimals).padStart(width);
      }
      
      function formatNum(num, width=8, decimals=2){
          return num.toFixed(decimals).padStart(width);
      }
      
      const uXStr = formatNum(u.x);
      const uYStr = formatNum(u.y);
      const vXStr = formatNum(v.x);
      const vYStr = formatNum(v.y);
      const crossStr = formatNum(cross);
      const dotStr = formatNum(dot);
      const angleRadStr = formatNum(angleRad,8,3);
      const angleDegStr = formatNum(angleDeg,6,1);
      const tangentStr =  tangent === 0 ? formatNum(tangent,8,4) : 'undefined';
      const rauPhaseStr = formatNum(rauPhase,6,3);
      const rauSineStr = formatNum(rauSine,8,3);
      const rauCosStr = formatNum(rauCos,8,3);
      const rauRadStr = formatNum(rauRad,8,3);
      const rauDegStr = formatNum(rauDeg,6,1);
      
      displays.resultsContent.textContent =
      `
      u = (${uXStr}, ${uYStr})
      v = (${vXStr}, ${vYStr})
      Cross = ${crossStr}
      Dot   = ${dotStr}
      ---------------
	  Radian = ${angleRadStr}${angleDegStr}°
	  RAUnit =   ${rauPhaseStr}
      ---------------
	  tan(θ) =  ${tangentStr}
	  sin(θ) = ${rauSineStr}
	  cos(θ) = ${rauCosStr}`;
      //θ = ${rauRadStr} rad | ${rauDegStr}°

      drawChordConnection(ctx, v, u, arcRadius);
      currentPhase = rauPhase;
      if (showConv.checked) drawConversionDiagram(rauPhase);
  }
	const convCanvas = document.getElementById("conversionCanvas");
	const convCtx = convCanvas.getContext("2d");
	const convPanel = document.getElementById("conversionPanel");
	const showConv = document.getElementById("showConversion");

	showConv.addEventListener("change", () => {
	  convPanel.style.display = showConv.checked ? "block" : "none";
	  if (showConv.checked) drawConversionDiagram(currentPhase);
	});

	let currentPhase = 0; // tracked globally

	function drawConversionDiagram(rauPhase) {
	  const ctx = convCtx;
	  const w = convCanvas.width;
	  const h = convCanvas.height;
	  ctx.clearRect(0,0,w,h);

	  const r = 60;
	  const cx = w/2, cy = h/2 + 10;

	  // Base circle + title
	  ctx.strokeStyle = "#333";
	  ctx.lineWidth = 2;
	  ctx.beginPath();
	  ctx.arc(cx, cy, r, 0, 2*Math.PI);
	  ctx.stroke();

	  ctx.fillStyle = "#000";
	  ctx.font = "11px monospace";
	  //ctx.fillText("RAU ↔ Degrees ↔ Radians", w/2 - 100, 20);

	  // Quadrant labels
	  const labels = [
	    { t: 0, label: "1 RAU\n90°" },
		{ t: 1, label: "0 RAU\n0°/360°" },
	    { t: 2, label: "3 RAU\n270°" },
		{ t: 3, label: "2 RAU\n180°" }
	    //{ t: 4, label: "4 RAU\n360°\n2π" }
	  ];
	  ctx.fillStyle = "#333";
	  labels.forEach(l => {
	    const a = (l.t/4)*2*Math.PI - Math.PI/2;
	    const x = cx + Math.cos(a)*(r + 28);
	    const y = cy + Math.sin(a)*(r + 28);
	    l.label.split("\n").forEach((line,i)=>{
	      ctx.fillText(line, x - 18, y + i*12);
	    });
	  });

	  // Draw arcs (quadrant highlighting)
	  const quadColors = ["#5cc0ff","#ffb35c","#d28aff","#68e186"];
	  for (let q = 0; q < 4; q++) {
	    ctx.strokeStyle = quadColors[q];
	    ctx.lineWidth = 3;
	    ctx.beginPath();
	    ctx.arc(cx, cy, r, (q/4)*2*Math.PI - Math.PI/2, ((q+1)/4)*2*Math.PI - Math.PI/2);
	    ctx.stroke();
	  }

	  // Compute angle in radians (RAU → radians)
	  const theta = (rauPhase / 4) * 2 * Math.PI;

	  // Draw current phase marker
	  const px = cx - Math.sin(theta - Math.PI/2) * r;
	  const py = cy + Math.cos(theta + Math.PI/2) * r;
	  ctx.fillStyle = "red";
	  ctx.beginPath();
	  ctx.arc(px, py, 6, 0, 2*Math.PI);
	  ctx.fill();

	  // Live readout
	  const degrees = (rauPhase / 4) * 360;
	  ctx.fillStyle = "#000";
	  ctx.font = "12px monospace";
	  //ctx.fillText(`Current → ${rauPhase.toFixed(3)} RAU | ${degrees.toFixed(1)}° | ${(theta).toFixed(3)} rad`, w/2 - 140, h - 15);
	}
  // add listeners
  Object.values(controls).forEach(c => c.addEventListener('input', render));
  render();
})();
</script>

</body>
</html>
