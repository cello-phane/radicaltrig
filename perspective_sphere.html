<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wireframe Sphere</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: white;
            font-family: monospace;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #333;
            background: linear-gradient(45deg, #001122, #000511);
        }
        
        #controlsContainer  {
        	display: block;
        }

        .controls {
            position: absolute;
            top: 50px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            display: block;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            width: 120px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        .value {
            color: #00ff88;
            font-weight: bold;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 11px;
            max-width: 300px;
        }
        
        .animation-controls {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
        
        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        button:hover {
            background: #555;
        }
        
        button.active {
            background: #007755;
        }
    </style>
</head>
<body>
    <button id="toggleCtrls" onclick="hideControls();">Toggle Controls</button> 
    <div id="controlsContainer">
    <div class="controls">
        <div class="control-group">
            <label>Rotation X:</label>
            <input id="rotX" type="range" min="-360" max="360" value="0">
            <span class="value" id="rotXVal">0°</span>
        </div>
        <div class="control-group">
            <label>Rotation Y:</label>
            <input id="rotY" type="range" min="-360" max="360" value="0">
            <span class="value" id="rotYVal">0°</span>
        </div>        
        <div class="control-group">
            <label>Rotation Z:</label>
            <input id="rotZ" type="range" min="-360" max="360" value="0">
            <span class="value" id="rotZVal">0°</span>
        </div>
        <div class="control-group">
            <label>Semicircle:</label>
            <input type="range" id="semicircle" min="0" max="100" value="100">
            <span class="value" id="semicircleVal">100</span>
        </div>
        <div class="control-group">
            <label>Meridians:</label>
            <input type="range" id="meridians" min="8" max="32" value="27">
            <span class="value" id="meridiansVal">27</span>
        </div>
        <div class="control-group">
            <label>Parallels:</label>
            <input type="range" id="parallels" min="8" max="32" value="28">
            <span class="value" id="parallelsVal">28</span>
        </div>
        <div class="control-group">
            <label>Perspective:</label>
            <input type="range" id="perspective" min="100" max="1000" value="1000">
            <span class="value" id="perspectiveVal">730</span>
        </div>
        <div class="control-group">
            <label>Radius(zoom):</label>
            <input type="range" id="radius" min="10" max="300" value="232">
            <span class="value" id="radiusVal">232</span>
        </div>
        <div class="animation-controls">
	        <label>Culling(back):</label>
	        <input type="range" id="cullingf" min="0" max="100" value="100">
	        <span class="value" id="cullingfVal">100</span>
	        <div>
	        <label>Culling(front):</label>
	        <input type="range" id="cullingb" min="0" max="100" value="0">
	        <span class="value" id="cullingbVal">9</span>
	        </div>
	        <div>
			<label>Spark:</label>
            <input type="range" id="spark" min="0" max="300" value="10">
            <span class="value" id="sparkVal">10</span>
	        </div>
	        
            <div class="control-group">
              <label>Rotation Speed:</label>
              <input type="range" id="rotationSpeed" min="0" max="200" value="5">
              <span class="value" id="rotationSpeedVal">5</span>
            </div>
            <button id="toggleAnim">Start Animation</button>
            <button id="toggleFieldLines">Spark</button>
        </div>
    </div>
    </div>
    
    <canvas id="canvas" width="960" height="720"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;
        let drawingFieldLines = false;

        // Control elements
        const controls = {
            rotX: document.getElementById('rotX'),
            rotY: document.getElementById('rotY'),
            rotZ: document.getElementById('rotZ'),
            semicircle: document.getElementById('semicircle'),
            meridians: document.getElementById('meridians'),
            parallels: document.getElementById('parallels'),
            perspective: document.getElementById('perspective'),
            radius: document.getElementById('radius'),
            cullingf: document.getElementById('cullingf'),
            cullingb: document.getElementById('cullingb'),            
            rotationSpeed: document.getElementById('rotationSpeed'),
            spark: document.getElementById('spark')
        };
        
        const values = {
            rotXVal: document.getElementById('rotXVal'),
            rotYVal: document.getElementById('rotYVal'),
            rotZVal: document.getElementById('rotZVal'),
            semicircleVal: document.getElementById('semicircleVal'),
            meridiansVal: document.getElementById('meridiansVal'),
            parallelsVal: document.getElementById('parallelsVal'),
            perspectiveVal: document.getElementById('perspectiveVal'),
            radiusVal: document.getElementById('radiusVal'),
			cullingfVal: document.getElementById('cullingfVal'),
	        cullingbVal: document.getElementById('cullingbVal'), 
            rotationSpeedVal: document.getElementById('rotationSpeedVal'),
            sparkVal: document.getElementById('sparkVal')
        };
        let rotXAngle 		= parseFloat(controls.rotX.value); // degrees
        let rotYAngle 		= parseFloat(controls.rotY.value); // degrees
        let rotZAngle 		= parseFloat(controls.rotZ.value); // degrees

		// ===========================================
		// Smooth interpolation between frames
		// ===========================================
		let animStartTime = 0;
		const animDuration = 2000; // 2 seconds
		let animatingRotation = false;
		let startRot = { x: 0, y: 0, z: 0 };
		let targetRot = { x: 0, y: 0, z: 0 };

        // Animation controls
        const toggleAnimBtn = document.getElementById('toggleAnim');
        const toggleFieldLinesBtn = document.getElementById('toggleFieldLines');
        
        // Resized point for semicricle
        let semicirclePtSize = 0;

        // Trig functions
        function rsin(x) {
            const a = 1.0 - 2.0 * x + 2.0 * x * x;
           	const invSqrtA = 1.0 / Math.sqrt(a);
          	 return x * invSqrtA;
        }

        function rcos(x) {
            const a = 1.0 - 2.0 * x + 2.0 * x * x;
            const invSqrtA = 1.0 / Math.sqrt(a);
            return (1.0 - x) * invSqrtA;
        }

        // Convert from degrees to your frequency domain (period 4)
        function degreesToFreq(degrees) {
            return (degrees / 90.0); // Maps 0-360° to 0-4 frequency units
        }
        
        // Quadrant mapping for frequency domain trig
        function getRotationComponents(freq) {
		    const phase = ((freq % 4.0) + 4.0) % 4.0;  // Normalize to 0-4 range
		    const quadrant = Math.floor(phase);
		    const t = phase - quadrant;
		    const s = rsin(t);
		    const c = rcos(t);
		    const q0 = Number(quadrant === 0);
		    const q1 = Number(quadrant === 1);
		    const q2 = Number(quadrant === 2);
		    const q3 = Number(quadrant === 3);
            // Quadrant mapping
            /*let sin_result, cos_result;
            if (quadrant === 0) { sin_result = s; cos_result = c;
            } else if (quadrant === 1) { sin_result = c; cos_result = -s;
            } else if (quadrant === 2) { sin_result = -s; cos_result = -c;
            } else { sin_result = -c; cos_result = s;
            }*/
            let cos_result = c*q0 - s*q1 - c*q2 + s*q3;
            let sin_result = (s*q0 + c*q1 - s*q2 - c*q3) * (Math.sign(freq)); 
            return { sin: sin_result, cos: cos_result };
        }

        // 3D Rotations
        function rotateX(point, angleDegrees) {
            const freq = degreesToFreq(angleDegrees);
            const { sin, cos } = getRotationComponents(freq);
            return {
                x: point.x,
                y: point.y * cos - point.z * sin,
                z: point.y * sin + point.z * cos
            };
        }
        
        function rotateZ(point, angleDegrees) {
            const freq = degreesToFreq(angleDegrees);
            const { sin, cos } = getRotationComponents(freq);
            return {
                x: point.x * cos + point.z * sin,
                y: point.y,
                z: -point.x * sin + point.z * cos
            };
        }

		function rotateY(point, angleDegrees) {
			const freq = degreesToFreq(angleDegrees);
		    const { cos, sin } = getRotationComponents(freq);
		    return { 
		    	x: point.x * cos - point.y * sin, 
		    	y: point.x * sin + point.y * cos, 
		    	z: point.z
		    };
		}

		function rotateXandZ(point, rotX, rotZ) {
		    // Combine for a plane axis rotation
		    const { cos: c1, sin: s1 } = getRotationComponents(degreesToFreq(rotX)); // X-axis
		    const { cos: c2, sin: s2 } = getRotationComponents(degreesToFreq(rotZ)); // Z-axis

		    // First rotate X
		    const y1 = point.y * c1 - point.z * s1;
		    const z1 = point.y * s1 + point.z * c1;
		    const x1 = point.x;
			// Then rotate Z
		    const x2 = x1 * c2 + z1 * s2;
		    const z2 = -x1 * s2 + z1 * c2;

		    return { x: x2, y: y1, z: z2 };
		}

        // Project 3d to perspective
        function project3D(point3d, perspective) {
            const scale = perspective / (perspective + point3d.z);
            return {
                x: centerX + point3d.x * scale,
                y: centerY + point3d.y * scale,
                scale: scale
            };
        }

        // Used for generating sphere points along a half great circle
        function semicircle(r, a) {
            const dx = 1 / r;
            let sum = 0;
            
            for (let i = 0; i < r; i++) {
                const x = r + i * dx;
                if (x <= r) {
                    const height = Math.sqrt(r * r - x * x);
                    sum += height * dx;
                }
            }
            return sum;
        }
        
        // Generate sphere points
        function generateSpherePoints(radius, meridianCount, parallelCount, semicircleParam) {
            const points = [];
            const scParam = semicircleParam; // Parameter (0-1)
            
            // Generate meridians using frequency domain (0-4 instead of 0-2π)
            for (let m = 0; m < meridianCount; m++) {
                const phiFreq = (m / meridianCount) * 4.0; // Longitude
                const meridianPoints = [];
                
                for (let p = 0; p <= parallelCount; p++) {
                    const thetaFreq = (p / parallelCount) * 2.0; // Latitude
                    const semiCirc = semicircle(radius, scParam);
                    // Spherical to Cartesian
                    const thetaTrig = getRotationComponents(thetaFreq);
                    const phiTrig = getRotationComponents(phiFreq);
                    
                    const x = radius * thetaTrig.sin * phiTrig.cos;
                    const y = radius * thetaTrig.cos;
                    const z = radius * thetaTrig.sin * phiTrig.sin;
                    
                    meridianPoints.push({ x, y, z });
                }
                points.push(meridianPoints);
            }
            
            // Generate parallels
            const parallelLines = [];
            for (let p = 0; p < parallelCount; p++) {
                const thetaFreq = (p / parallelCount) * 2.0; // Latitude
                const parallelPoints = [];
                
                for (let m = 0; m <= meridianCount; m++) {
                    const phiFreq = (m / meridianCount) * 4.0; // Longitude
                    const semiCirc = semicircle(radius, scParam);
                    // Spherical to Cartesian
                    const thetaTrig = getRotationComponents(thetaFreq);
                    const phiTrig = getRotationComponents(phiFreq);
                    
                    const x = radius * thetaTrig.sin * phiTrig.cos;
                    const y = radius * thetaTrig.cos;
                    const z = radius * thetaTrig.sin * phiTrig.sin;
                    
                    parallelPoints.push({ x, y, z });
                }
                parallelLines.push(parallelPoints);
            }
            
            return { meridians: points, parallels: parallelLines };
        }
        
		function generateGravityField(radius, rayCount, shellCount) {
		    const fieldLines = [];
		    
		    // Generate field lines pointing radially inward
		    for (let i = 0; i < rayCount; i++) {
		        const thetaFreq = (i / rayCount) * 2.0; // Latitude (RAU)
		        
		        for (let j = 0; j < rayCount; j++) {
		            const phiFreq = (j / rayCount) * 4.0; // Longitude (RAU)
		            
		            // One field line with multiple shell points
		            const line = [];
		            
		            for (let shell = 1; shell <= shellCount; shell++) {
		                const r = radius * shell / shellCount;
		                const forceMagnitude = 1 / (r * r);
		                
		                const thetaTrig = getRotationComponents(thetaFreq);
		                const phiTrig = getRotationComponents(phiFreq);
		                
		                const x = r * thetaTrig.sin * phiTrig.cos;
		                const y = r * thetaTrig.cos;
		                const z = r * thetaTrig.sin * phiTrig.sin;
		                
		                line.push({ x, y, z, force: forceMagnitude });
		            }
		            
		            fieldLines.push(line);
		        }
		    }
		    
		    return fieldLines;
		}

        
        // Drawing functions
        function drawLine(from, to, color = '#00ff88', width = 1) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
        }
        
        function drawPoint(point, color = '#ff4444', size = 3) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function updateFPS() {
          frameCount++;
          const currentTime = performance.now();
          const elapsed = currentTime - lastTime;
          
          if (elapsed >= 1000) { // Update every 1 second
            fps = Math.round((frameCount * 1000) / elapsed);
            frameCount = 0;
            lastTime = currentTime;
          }
          
          return fps;
        }

		function drawBlurredLine(from, to, color, width, blur) {
		    const layers = 3; // More = smoother but slower
		    
		    for (let i = 0; i < layers; i++) {
		        const offset = (i / layers) * blur;
		        const alpha = (1 - i / layers) * 0.05; // Decreasing opacity
		        
		        ctx.strokeStyle = `rgba(255, 100, 100, ${alpha})`;
		        ctx.lineWidth = width + offset;
		        ctx.beginPath();
		        ctx.moveTo(from.x, from.y);
		        ctx.lineTo(to.x, to.y);
		        ctx.stroke();
		    }
		}
        
        // Main render function using RAU radical angle system
        function render() {
       		ctx.clearRect(0, 0, canvas.width, canvas.height);
            const semicircle    	= parseFloat(controls.semicircle.value) / 100; // 0.01..1.0
            const meridianCount 	= parseInt(controls.meridians.value);
            const parallelCount 	= parseInt(controls.parallels.value);
            const perspective 		= parseFloat(controls.perspective.value);
            const radius 			= parseInt(controls.radius.value);
            const avgLinecount      = 0.5*(meridianCount+parallelCount);
			const cullingfPercent 	= parseFloat(controls.cullingf.value);
			const cullingbPercent 	= parseFloat(controls.cullingb.value);			
            const sphereData 		= generateSpherePoints(radius, meridianCount, parallelCount, semicircle);
            
            const cullF             = (1/(cullingfPercent))*avgLinecount*radius; //front face
            const cullB             = -(1/(cullingbPercent))*avgLinecount*radius;//back face
            const sparkEffect		= parseInt(controls.spark.value);

		    fieldLines              = generateGravityField((frameCount%2), ((frameCount/2)%12), 10);
			fieldLines.forEach(line => {
			    const projectedPoints = [];
			    const transformedPoints = [];
                let projected = [];   
			    line.forEach(point => {
			        let transformed = rotateXandZ(point, rotXAngle, rotZAngle);
			        transformed = rotateY(transformed, rotYAngle);
			        const projected = project3D(transformed, perspective);
			        projectedPoints.push(projected);
			    });
			    if (drawingFieldLines) {
			    for (let i = 0; i < parallelCount; i++) {
				    // Draw the field line
	                const brightness = (animateRotation/2)%12*Math.PI/2;
					const color = `rgba(255, 255, 255, ${brightness})`;
					drawBlurredLine(projectedPoints[0], projectedPoints[1], color, i*(0.01*radius), sparkEffect);
				}
			    }
			});
						
            // Transform and project meridians
            sphereData.meridians.forEach((meridian, mIndex) => {
                const projectedPoints = [];
                const transformedPoints = [];
                let projected = [];
                meridian.forEach(point => {
                    let transformed = rotateXandZ(point, rotXAngle, rotZAngle);
    				transformed = rotateY(transformed, rotYAngle);
 					transformedPoints.push(transformed);   					
                    projected = project3D(transformed, perspective);
                    projectedPoints.push(projected);
                });
                
                // Draw meridian lines
                for (let i = 0; i < projectedPoints.length - 1; i++) {
   				    if (cullingfPercent > 0 || cullingbPercent > 0) {
               	      if (transformedPoints[i].z + transformedPoints[i + 1].z > cullF) continue;
               	      if (transformedPoints[i].z + transformedPoints[i + 1].z < cullB) continue;
               	    }
                    const brightness = Math.max(0.5, projectedPoints[i].scale * 0.7);
                    const color = `rgba(0, 255, 136, ${brightness})`;
                	drawLine(projectedPoints[i], projectedPoints[i + 1], color, brightness);
	               	// Highlight special meridians affected by integration
	                if (mIndex === Math.floor(meridianCount * semicircle)) {
	                    if (radius < 100) {
	                    	semicirclePtSize = 1+(canvas.width/canvas.height)/1.25;
	                    }
	                    else {
	                    	semicirclePtSize = 1+(canvas.width/canvas.height);
	                    }
	                    projectedPoints.forEach(point => {
	                        drawPoint(point, '#ff8800', semicirclePtSize);
	                    });
	                }
                }
                
            });
            
            // Transform and project parallels
            sphereData.parallels.forEach(parallel => {
                const projectedPoints = [];
                const transformedPoints = [];
                let projected = [];                
                parallel.forEach(point => {
                    let transformed = rotateXandZ(point, rotXAngle, rotZAngle);
    				transformed = rotateY(transformed, rotYAngle);
	    			transformedPoints.push(transformed);
	                projected = project3D(transformed, perspective);
	                projectedPoints.push(projected);
                });
                
                // Draw parallel lines
                for (let i = 0; i < projectedPoints.length - 1; i++) {
   				    if (cullingfPercent > 0 || cullingbPercent > 0) {
               	      if (transformedPoints[i].z + transformedPoints[i + 1].z > cullF) continue;
               	      if (transformedPoints[i].z + transformedPoints[i + 1].z < cullB) continue;
               	    }
                    const brightness = Math.max(0.5, projectedPoints[i].scale * 0.7);
                    const color = `rgba(136, 136, 255, ${brightness})`;
                    drawLine(projectedPoints[i], projectedPoints[i + 1], color, brightness);
                }
            });
			const currentFps = updateFPS();
			  
		    // Display FPS on canvas
		    ctx.fillStyle = '#00ff00';
		    ctx.font = '12px monospace';
		    ctx.fillText(`FPS: ${currentFps}`, 10, 20);

        }
        
        function hideControls() {
	        var contentElement = document.getElementById("controlsContainer");
	        if (contentElement.style.display === "none") {
	            contentElement.style.display = "block"; // Show the element
	        } else {
	            contentElement.style.display = "none"; // Hide the element
	        }
   		 }
        
		// =======================================
		// Smooth rotation animation controls
		// =======================================

		function smoothstep(t) {
		  return t * t * (3 - 2 * t);
		}
        function stepOnce() {
            // Single step animation
            controls.rotZ.value = (parseFloat(controls.rotZ.value) + 1) % 360;
            values.rotZVal.textContent = controls.rotZ.value + '°';
            render();
        }
		function startRotationAnimation(newRotX, newRotY, newRotZ) {
		  startRot = { x: rotXAngle, y: rotYAngle, z: rotZAngle };
		  targetRot = { x: newRotX, y: newRotY, z: newRotZ };
		  animStartTime = performance.now();
		  animatingRotation = true;
		  toggleAnimBtn.textContent = 'Stop Animation';
		  toggleAnimBtn.classList.add('active');
		  requestAnimationFrame(animateRotation);
		}

		function stopRotationAnimation() {
		  animatingRotation = false;
		  toggleAnimBtn.textContent = 'Start Animation';
		  toggleAnimBtn.classList.remove('active');
		}
		function animateRotation(timestamp) {
		  const elapsed = timestamp - animStartTime;
		  const loop = true; // continuous smooth looping (set false for one-time)
		  const duration = animDuration;

		  let t = (elapsed % duration) / duration;
		  const s = smoothstep(t);

		  const speed = parseFloat(controls.rotationSpeed.value) / 100; // normalize 0..2
		  const tSec = elapsed * 0.001 * speed; // apply speed factor

		  //rotXAngle = Math.sin(tSec) * 30;
		  //rotYAngle = Math.cos(tSec * 1.2) * 30;
		  rotZAngle = (startRot.z + tSec * 180) % 360;
		  
		  // Update sliders and display values
		  controls.rotX.value = rotXAngle;
		  controls.rotY.value = rotYAngle;
		  controls.rotZ.value = rotZAngle;

		  values.rotXVal.textContent = rotXAngle.toFixed(1) + '°';
		  values.rotYVal.textContent = rotYAngle.toFixed(1) + '°';
		  values.rotZVal.textContent = rotZAngle.toFixed(1) + '°';
		  render();
		  if (animatingRotation && (loop || t < 1)) {
		    requestAnimationFrame(animateRotation);
		  } else {
		    animatingRotation = false;
		    stopRotationAnimation();
		  }
		}

		function toggleAnimation() {
		  if (!animatingRotation) {
		    // Start smooth looping rotation
		    startRotationAnimation(rotXAngle, rotYAngle, rotZAngle + 360);
		  } else {
		    stopRotationAnimation();
		  }
		}
   		
        function startFieldLineAnimation() {
        	if (!drawingFieldLines) {
        		drawingFieldLines = true;
        	}
        	toggleFieldLinesBtn.classList.add('active');
        	toggleFieldLinesBtn.textContent = 'Spark';
        }

        function stopFieldLineAnimation() {
        	if (drawingFieldLines) {
        		drawingFieldLines = false;
        	}
        	toggleFieldLinesBtn.classList.remove('active');	
        	toggleFieldLinesBtn.textContent = 'No Spark';
        }

		function toggleFieldLinesAnimation() {
			if (drawingFieldLines) {
			    stopFieldLineAnimation();
			} else {
			    startFieldLineAnimation();
			}
		}

		Object.keys(controls).forEach(key => {
		  controls[key].addEventListener('input', (e) => {
		    //if (animatingRotation) return; // Ignore manual input during animation
		    const value = parseFloat(e.target.value);

		    if (key === 'rotX') rotXAngle = value;
		    if (key === 'rotY') rotYAngle = value;
		    if (key === 'rotZ') rotZAngle = value;

		    if (key === 'semicircleParam') {
		      values[key + 'Val'].textContent = (value / 100).toFixed(2);
		    } else if (key === 'rotX' || key === 'rotY' || key === 'rotZ') {
		      values[key + 'Val'].textContent = value + '°';
		    } else if (key === 'rotationSpeed') {
			  values[key + 'Val'].textContent = value;
		    } else {
		      values[key + 'Val'].textContent = value;
		    }

		    render();
		    
		  });
		});
        // Animation control event listeners
        toggleAnimBtn.addEventListener('click', toggleAnimation);
        toggleFieldLinesBtn.addEventListener('click', toggleFieldLinesAnimation);
        // Double-click canvas to toggle animation (legacy support)
        canvas.addEventListener('dblclick', toggleAnimation);
		
        // Initial render
        render();

    </script>
</body>
</html>
