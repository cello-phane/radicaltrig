<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <title>RAU Clock Widget</title>
  <link href="css/style_perspective_sphere.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div style="position: relative; display: inline-block;">
	<canvas id="rauClock" width="650" height="650" style="border:2px solid #444; border-radius:50%; display:block; margin:auto;"></canvas>
  </div>
  <script src="js/rau.js"></script>
  <script>
    const canvas = document.getElementById("rauClock");
    const ctx = canvas.getContext("2d");
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const radius = Math.min(cx, cy);

    // === Static Precompute ===
    const secHandPositions = [];
    for (let sec = 0; sec < 60; sec++) {
      const t = (sec / 60) * 4;
      secHandPositions.push({
        sin: radicalSine(t),
        cos: radicalCosine(t),
      });
    }

    // === Draw background once ===
    function drawStaticBackground() {
      ctx.save();

      // Outer circle
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#222";
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
      ctx.stroke();

      // Tick marks
      ctx.lineCap = "round";
      for (let i = 0; i < 60; i++) {
        const { sin, cos } = secHandPositions[i];
        const inner = i % 5 === 0 ? radius * 0.85 : radius * 0.93;
        const outer = radius * 0.97;
        ctx.beginPath();
        ctx.moveTo(cx + inner * sin, cy - inner * cos);
        ctx.lineTo(cx + outer * sin, cy - outer * cos);
        ctx.lineWidth = i % 5 === 0 ? 3 : 1;
        ctx.strokeStyle = i % 5 === 0 ? "#333" : "#999";
        ctx.stroke();
      }

      // Fancy symbol (inner decorative pattern)
      const innerRX = radius * 0.2;
      const innerRY = radius * 0.2;
      for (let i = 0; i < 60; i++) {
        const next = (i + 1) % 60;
        const s = 0.45, e = 0.55;
        const sx = cx + secHandPositions[next].sin * innerRX * s;
        const sy = cy - secHandPositions[next].cos * innerRY * s;
        const ex = cx + secHandPositions[i].sin * innerRX * e;
        const ey = cy - secHandPositions[i].cos * innerRY * e;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawHand(len, sin, cos, color, width) {
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + len * sin, cy - len * cos);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = "round";
      ctx.stroke();
    }

    // === Animation ===
    const startMillis = new Date().getSeconds() * 1000 + new Date().getMilliseconds();
    let startTime = performance.now() - startMillis;

    function animate(timestamp) {
      const now = new Date(); // ⬅️ MOVE inside animation loop
    
      const elapsed = (timestamp - startTime) / 1000;
      const secondsFrac = elapsed % 60;
      const sec = Math.floor(secondsFrac);
      const nextSec = (sec + 1) % 60;
      const frac = secondsFrac - sec;
    
      const currPos = secHandPositions[sec];
      const nextPos = secHandPositions[nextSec];
      const sin = currPos.sin + (nextPos.sin - currPos.sin) * frac;
      const cos = currPos.cos + (nextPos.cos - currPos.cos) * frac;
    
      // Compute minute and hour positions freshly every frame
      const minuteFrac = (now.getMinutes() + now.getSeconds() / 60) / 60; // fractional minute
      const hourFrac = ((now.getHours() % 12) + now.getMinutes() / 60) / 12; // fractional hour
    
      const minPos = {
        sin: radicalSine(minuteFrac * 4),
        cos: radicalCosine(minuteFrac * 4)
      };
      const hrPos = {
        sin: radicalSine(hourFrac * 4),
        cos: radicalCosine(hourFrac * 4)
      };
    
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawStaticBackground(); // redraw or reuse offscreen cache
    
      // Draw hands
      drawHand(radius * 0.97, sin, cos, "red", 3);    // second
      drawHand(radius * 0.6, minPos.sin, minPos.cos, "blue", 4);  // minute
      drawHand(radius * 0.35, hrPos.sin, hrPos.cos, "green", 6);  // hour
    
      requestAnimationFrame(animate);
    }
    

    // Start clock
    drawStaticBackground(); // draw static elements before animation
    requestAnimationFrame(animate);
  </script>
</body>
</html>
