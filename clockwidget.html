<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clock Widget</title>
    <link href="css/style_perspective_sphere.css" rel="stylesheet" type="text/css">
</head>

<body>
    <button type="button" data-theme-toggle aria-label="Change Theme">Dark/Light</button>
    <button id="toggleCtrls" onclick="hideControls();">Toggle Controls</button>
    <div id="controlsContainer">
	<div class="controls">
        <div class="control-group">
        <input type="range" min="1" max="100" value="25" class="slider" id="design" step="1">
        üí†<span class="value" id="designVal">25</span>
        </div>
        <div class="control-group">
        <input type="range" min="0.1" max="5" value="0.5" class="slider" id="opacity" step="0.1">
        ëóä<span class="value" id="opacityVal">0.5</span>
        </div>
        <div class="control-group">
        <input type="range" min="50" max="1000" value="1000" class="slider" id="size" step="50">
        üîç<span class="value" id="sizeVal">1000</span>
        </div>
	</div>
    </div>
    <canvas id="rauClock" width="750" height="750" style="background: transparent; --canvas-border: transparent;"></canvas>
    <script src="js/rau.js"></script>
    <script>
        (function() {
            const theme = localStorage.getItem("theme") || "dark";
            document.documentElement.dataset.theme = theme;
        })();

        function calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        }) {
            if (localStorageTheme !== null) {
                return localStorageTheme;
            }

            if (systemSettingDark.matches) {
                return "dark";
            }

            return "light";
        }

        const localStorageTheme = "dark";
        const systemSettingDark = window.matchMedia("(prefers-color-scheme: dark)");
        let currentThemeSetting = calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        });

        const button = document.querySelector("[data-theme-toggle]");

        button.addEventListener("click", () => {
            const newTheme = currentThemeSetting === "dark" ? "light" : "dark";
            const newCta = newTheme === "dark" ? "Switch to Light" : "Switch to Dark";
            button.innerText = newCta;
            button.setAttribute("aria-label", newCta);
            document.querySelector("html").setAttribute("data-theme", newTheme);
            localStorage.setItem("theme", newTheme);
            currentThemeSetting = newTheme;
            drawStaticBackgroundOnce();
        });

        function getThemeColors() {
            const theme = localStorage.getItem("theme") || "dark";

            if (theme === "light") {
                return {
                    meridianRGB: [92, 74, 61],
                    parallelRGB: [201, 181, 160],
                    fieldLineRGB: [139, 0, 0]
                };
            } else {
                return {
                    meridianRGB: [0, 255, 136],
                    parallelRGB: [136, 136, 255],
                    fieldLineRGB: [255, 255, 255]
                };
            }
        }

        const canvas = document.getElementById("rauClock");
        const ctx = canvas.getContext("2d");
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = Math.min(cx, cy) * 0.9;

        const controls = {
            design: document.getElementById('design'),
            opacity: document.getElementById('opacity'),
            size: document.getElementById('size')
        };

        const values = {
            designVal: document.getElementById('designVal'),
            opacityVal: document.getElementById('opacityVal'),
            sizeVal: document.getElementById('sizeVal')
        };

        let design = parseInt(controls.design.value);
        let opacity = parseFloat(controls.opacity.value);
        let size = parseInt(controls.size.value);

        // ================================
        // Uniform Velocity Table Generation
        // ================================
        function generateUniformVelocityTable(divisions = 60) {
            const table = [];

            for (let i = 0; i < divisions; i++) {
                // RAU position: uniform steps from 0 to 4
                const rauPosition = (i / divisions) * 4;

                // Compute sin/cos once and store
                const sin = radicalSine(uniformVelocityRAU(rauPosition));
                const cos = radicalCosine(uniformVelocityRAU(rauPosition));

                table.push({ sin, cos, rauPosition });
            }

            return table;
        }

        // ================================
        // Interpolation from Table
        // ================================
        function getInterpolatedFromTable(table, secondsFrac) {
            // Map seconds (0-60) directly to RAU (0-4)
            const totalSeconds = secondsFrac % 60;
            const rauPosition = (totalSeconds / 60) * 4;

            // Find the two nearest table entries
            const indexFloat = (rauPosition / 4) * table.length;
            const index = Math.floor(indexFloat);
            const nextIndex = (index + 1) % table.length;
            const fraction = indexFloat - index;

            const current = table[index];
            const next = table[nextIndex];

            // Linear interpolation in sin/cos space
            const sin = current.sin + (next.sin - current.sin) * fraction;
            const cos = current.cos + (next.cos - current.cos) * fraction;

            return { sin, cos };
        }

        const uniformVelocityTable = generateUniformVelocityTable(60);

        function hideControls() {
            const contentElement = document.getElementById("controlsContainer");
            if (contentElement.style.display === "none") {
                contentElement.style.display = "block";
            } else {
                contentElement.style.display = "none";
            }
        }

        const staticBuffer = document.createElement("canvas");
        staticBuffer.width = canvas.width;
        staticBuffer.height = canvas.height;
        const staticCtx = staticBuffer.getContext("2d");

        // ================================
        // Draw Uniform Velocity Ticks
        // ================================
        function drawUniformVelocityTicks(ctx, cx, cy, radius, rauTable, opacity = 0.5, color = "rgba(255, 255, 255, ") {
            ctx.save();

            const tickRadius = radius * 0.92;
            const tickLength = radius * 0.08;

            rauTable.forEach((entry, index) => {
                const sin = entry.sin;
                const cos = entry.cos;

                const innerX = cx + sin * tickRadius;
                const innerY = cy - cos * tickRadius;
                const outerX = cx + sin * (tickRadius + tickLength);
                const outerY = cy - cos * (tickRadius + tickLength);

                ctx.beginPath();
                ctx.moveTo(innerX, innerY);
                ctx.lineTo(outerX, outerY);

                if (index % 5 === 0) {
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = `${color}1.0)`;
                } else {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = `${color}${opacity})`;
                }

                ctx.lineCap = "round";
                ctx.stroke();
            });

            ctx.restore();
        }

        // ================================
        // Draw Numbered Markers
        // ================================
        function drawNumberedMarkers(ctx, cx, cy, radius, rauTable, color = "white") {
            ctx.save();
            ctx.fillStyle = color;
            ctx.font = "12px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const markerRadius = radius * 0.80;

            for (let i = 0; i < rauTable.length; i += 5) {
                const entry = rauTable[i];
                const sin = entry.sin;
                const cos = entry.cos;

                const x = cx + sin * markerRadius;
                const y = cy - cos * markerRadius;

                ctx.fillText(i.toString(), x, y);
            }

            ctx.restore();
        }

        // ================================
        // Draw Static Background
        // ================================
        function drawStaticBackgroundOnce() {
            staticCtx.clearRect(0, 0, staticBuffer.width, staticBuffer.height);

            staticCtx.save();
            const colors = getThemeColors();
            const rgb = colors.parallelRGB;

            // Outer circle
            staticCtx.lineWidth = 3;
            staticCtx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
            staticCtx.beginPath();
            staticCtx.arc(cx, cy, radius, 0, 2 * Math.PI);
            staticCtx.stroke();

            // Uniform velocity ticks
            drawUniformVelocityTicks(staticCtx, cx, cy, radius, uniformVelocityTable, 0.6, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, `);

            // Numbered markers
            drawNumberedMarkers(staticCtx, cx, cy, radius, uniformVelocityTable, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.8)`);

            staticCtx.lineCap = "round";

            // Fancy inner pattern
            const rauSinTable = [];
            const rauCosTable = [];
            for (let i = 0; i < 360; i++) {
                const t = (i / design);
                rauSinTable.push(radicalSine(t));
                rauCosTable.push(radicalCosine(t));
            }

            for (let i = 0; i < 360; i++) {
                const outerRX = size;
                const outerRY = size;
                const innerRX = size;
                const innerRY = size;
                const next = (i - 1) % 25;
                const s = 0.25;
                const e = 0.25;
                const sx = cx + rauSinTable[next] * innerRX * s;
                const sy = cy - rauCosTable[next] * innerRY * s;
                const ex = cx + rauSinTable[i] * innerRX * e;
                const ey = cy - rauCosTable[i] * innerRY * e;
                staticCtx.beginPath();
                staticCtx.moveTo(sx, sy);
                staticCtx.lineTo(ex, ey);
                staticCtx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
                staticCtx.lineWidth = opacity;
                staticCtx.stroke();
            }

            staticCtx.restore();
        }

        function drawHand(len, sin, cos, color, width) {
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + len * sin, cy - len * cos);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = "round";
            ctx.stroke();
        }

        // ================================
        // Uniform Velocity Conversion (tan-based)
        // ================================
        function uniformVelocityRAU(linearParam) {
            // Map linear parameter to uniform velocity RAU
            // This compensates for the non-linear speed of RAU functions
            const phase = linearParam % 4;
            const quadrant = Math.floor(phase);
            const t = phase - quadrant;  // 0 to 1 within quadrant
            // Return adjusted RAU parameter
            return quadrant + uniformRAU(t);
        }

        // === Animation ===
        function animate() {
          const now = new Date();
        
          // Continuous time fractions
          const secFrac = (now.getSeconds() + now.getMilliseconds() / 1000) / 60;
          const minFrac = (now.getMinutes() + secFrac) / 60;
          const hrFrac  = ((now.getHours() % 12) + minFrac) / 12;
        
          // Convert linear progress ‚Üí uniform RAU parameter
          const rauSec = uniformVelocityRAU(secFrac * 4);
          const rauMin = uniformVelocityRAU(minFrac * 4);
          const rauHr  = uniformVelocityRAU(hrFrac * 4);
        
          // Evaluate radical trig functions
          const sec = { sin: radicalSine(rauSec), cos: radicalCosine(rauSec) };
          const min = { sin: radicalSine(rauMin), cos: radicalCosine(rauMin) };
          const hr  = { sin: radicalSine(rauHr),  cos: radicalCosine(rauHr) };
        
          // Draw
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(staticBuffer, 0, 0);
        
          drawHand(radius * 0.9, sec.sin, sec.cos, "red", 2);
          drawHand(radius * 0.6, min.sin, min.cos, "blue", 3);
          drawHand(radius * 0.4, hr.sin,  hr.cos,  "green", 4);
          values.designVal.textContent 	= design;
		  values.opacityVal.textContent = opacity;
		  values.sizeVal.textContent 	= size;
          requestAnimationFrame(animate);
        }

        // Start clock
        drawStaticBackgroundOnce();
        requestAnimationFrame(animate);

        Object.keys(controls).forEach(key => {
            controls[key].addEventListener('input', (e) => {
                if (key === 'design') {
                    design = parseInt(e.target.value);
                    drawStaticBackgroundOnce();
                }
                if (key === 'opacity') {
                    opacity = parseFloat(e.target.value);
                    drawStaticBackgroundOnce();
                }
                if (key === 'size') {
                    size = parseInt(e.target.value);
                    drawStaticBackgroundOnce();
                }
            });
        });
    </script>
</body>

</html>

