<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <title>RAU Clock Widget</title>
  <link href="css/style_perspective_sphere.css" rel="stylesheet" type="text/css">

</head>
<body>
  <canvas id="rauClock" width="650" height="650" style="background: transparent; --canvas-border: transparent;">></canvas>
  <script src="js/rau.js"></script>
  <script>
    const canvas = document.getElementById("rauClock");
    const ctx = canvas.getContext("2d");
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const radius = Math.min(cx, cy) * 0.9;

    // Precompute all hand positions for uniform spacing
    const secHandPositions = [];
    for (let sec = 0; sec < 60; sec++) {
      const t = (sec / 60) * 4;
      secHandPositions.push({
        sin: radicalSine(t),
        cos: radicalCosine(t),
      });
    }
    
    const minHandPositions = [];
    for (let min = 0; min < 60; min++) {
      const t = (min / 60) * 4;
      minHandPositions.push({
        sin: radicalSine(t),
        cos: radicalCosine(t),
      });
    }
    
    const hrHandPositions = [];
    for (let hr = 0; hr < 12; hr++) {
      const t = (hr / 12) * 4;
      hrHandPositions.push({
        sin: radicalSine(t),
        cos: radicalCosine(t),
      });
    }
    // === Draw background once ===
    function drawStaticBackground() {
      ctx.save();

      // Outer circle
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#222";
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
      ctx.stroke();

      // Tick marks
      ctx.lineCap = "round";
      for (let i = 0; i < 60; i++) {
        const { sin, cos } = secHandPositions[i];
        const inner = i % 5 === 0 ? radius * 0.85 : radius * 0.93;
        const outer = radius * 0.97;
        ctx.beginPath();
        ctx.moveTo(cx + inner * sin, cy - inner * cos);
        ctx.lineTo(cx + outer * sin, cy - outer * cos);
        ctx.lineWidth = i % 5 === 0 ? 3 : 1;
        ctx.strokeStyle = i % 5 === 0 ? "#333" : "#999";
        ctx.stroke();
      }
      const rauSinTable = [],
      rauCosTable = [];
      for (let i = 0; i < 60; i++) {
          const t = (i / 60) * 4;
          rauSinTable.push(radicalSine(t));
          rauCosTable.push(radicalCosine(t));
      }
      const outerRX = radius,
          outerRY = radius;
      const innerRX = 70,
          innerRY = 50;
      ctx.restore();
      for (let i = 0; i < 60; i++) {
        const next = (i + 1) % 60;
        const s = 0.45, e = 0.55;
        const sx = cx + secHandPositions[next].sin * innerRX * s;
        const sy = cy - secHandPositions[next].cos * innerRY * s;
        const ex = cx + secHandPositions[i].sin * innerRX * e;
        const ey = cy - secHandPositions[i].cos * innerRY * e;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawHand(len, sin, cos, color, width) {
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + len * sin, cy - len * cos);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = "round";
      ctx.stroke();
    }

    // === Animation ===
    const startMillis = new Date().getSeconds() * 1000 + new Date().getMilliseconds();
    let startTime = performance.now() - startMillis;

    function animate(timestamp) {
      const now = new Date();
      const elapsed = (timestamp - startTime) / 1000;
      
      // Second hand: smooth interpolation
      const secondsFrac = elapsed % 60;
      const sec = Math.floor(secondsFrac);
      const nextSec = (sec + 1) % 60;
      const secFrac = secondsFrac - sec;
      const secPos = interpolate(secHandPositions[sec], secHandPositions[nextSec], secFrac);
      
      // Minute hand: interpolate within 60 positions
      const totalSeconds = now.getMinutes() * 60 + now.getSeconds();
      const minIndex = Math.floor((totalSeconds / 3600) * 60);
      const minFrac = ((totalSeconds / 3600) * 60) - minIndex;
      const minPos = interpolate(minHandPositions[minIndex % 60], minHandPositions[(minIndex + 1) % 60], minFrac);
      
      // Hour hand: interpolate within 12 positions
      const totalMinutes = now.getHours() * 60 + now.getMinutes();
      const hrIndex = Math.floor((totalMinutes / 720) * 12) % 12;
      const hrFrac = ((totalMinutes / 720) * 12) - hrIndex;
      const hrPos = interpolate(hrHandPositions[hrIndex], hrHandPositions[(hrIndex + 1) % 12], hrFrac);
      
      // Draw
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawStaticBackground();
      
      drawHand(radius * 0.97, secPos.sin, secPos.cos, "red", 3);
      drawHand(radius * 0.6, minPos.sin, minPos.cos, "blue", 4);
      drawHand(radius * 0.06, hrPos.sin, hrPos.cos, "green", 6);
      
      requestAnimationFrame(animate);
    }
    
    function interpolate(p1, p2, t) {
      return {
        sin: p1.sin + (p2.sin - p1.sin) * t,
        cos: p1.cos + (p2.cos - p1.cos) * t
      };
    }

    // Start clock
    drawStaticBackground(); // draw static elements before animation
    requestAnimationFrame(animate);
  </script>
</body>
</html>
