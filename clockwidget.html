<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clock Widget</title>
    <link href="css/style_perspective_sphere.css" rel="stylesheet" type="text/css">
</head>

<body>
    <button type="button" data-theme-toggle aria-label="Change Theme">Dark/Light</button>
    <button id="toggleCtrls" onclick="hideControls();">Toggle Controls</button>
    <div id="controlsContainer">
	<div class="controls">
        <div class="control-group">
        <input type="range" min="1" max="100" value="25" class="slider" id="design" step="1">
        üí†<span class="value" id="designVal">25</span>
        </div>
        <div class="control-group">
        <input type="range" min="0.1" max="5" value="0.3" class="slider" id="opacity" step="0.1">
        ëóä<span class="value" id="opacityVal">0.3</span>
        </div>
        <div class="control-group">
        <input type="range" min="50" max="1000" value="250" class="slider" id="size" step="50">
        üîç<span class="value" id="sizeVal">250</span>
        </div>
	</div>
    </div>
    <canvas id="rauClock" width="750" height="750" style="background: transparent; --canvas-border: transparent;">></canvas>
    <script src="js/rau.js"></script>
    <script>
        (function() {
            const theme = localStorage.getItem("theme") || "dark"; // default
            document.documentElement.dataset.theme = theme;
        })();
        function calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        }) {
            if (localStorageTheme !== null) {
                return localStorageTheme;
            }

            if (systemSettingDark.matches) {
                return "dark";
            }

            return "light";
        }

        const localStorageTheme = "dark";
        const systemSettingDark = window.matchMedia("(prefers-color-scheme: dark)");
        let currentThemeSetting = calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        });
        // target the button using the data attribute we added earlier
        const button = document.querySelector("[data-theme-toggle]");

        button.addEventListener("click", () => {
            const newTheme = currentThemeSetting === "dark" ? "light" : "dark";

            // update the button text
            const newCta = newTheme === "dark" ? "Switch to Light" : "Switch to Dark";
            button.innerText = newCta;

            // use an aria-label if you are omitting text on the button
            // and using sun/moon icons, for example
            button.setAttribute("aria-label", newCta);

            // update theme attribute on HTML to switch theme in CSS
            document.querySelector("html").setAttribute("data-theme", newTheme);

            // update in local storage
            localStorage.setItem("theme", newTheme);

            // update the currentThemeSetting in memory
            currentThemeSetting = newTheme;
            //force the update of the theme for the canvas lines/etc.
            requestAnimationFrame(animate);
        });
        const themeBtn = document.querySelector('button[data-theme-toggle]');

        function getThemeColors() {
            const theme = localStorage.getItem("theme") || "dark";

            if (theme === "light") {
                return {
                    meridianRGB: [92, 74, 61], // Brown RGB values
                    parallelRGB: [201, 181, 160], // Beige RGB values
                    fieldLineRGB: [139, 0, 0] // Deep red RGB values
                };
            } else {
                return {
                    meridianRGB: [0, 255, 136], // Green RGB values
                    parallelRGB: [136, 136, 255], // Blue RGB values
                    fieldLineRGB: [255, 255, 255] // White RGB values
                };
            }
        }
        const canvas = document.getElementById("rauClock");
        const ctx = canvas.getContext("2d");
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = Math.min(cx, cy) * 0.9;

		// Control elements
		const controls = {
		    design: document.getElementById('design'),
		    opacity: document.getElementById('opacity'),
		    size: document.getElementById('size')
		};
        const values = {
		    designVal: document.getElementById('designVal'),
            opacityVal: document.getElementById('opacityVal'),
            sizeVal: document.getElementById('sizeVal')
        };
       	let opacity  = parseInt(controls.opacity.value);
        let design   = parseFloat(controls.design.value);
        let size 	 = parseInt(controls.size.value);
        
        // Precompute all hand positions for uniform spacing
        const secHandPositions = [];
        for (let sec = 0; sec < 60; sec++) {
            const t = (sec / 60) * 4;
            secHandPositions.push({
                sin: radicalSine(t),
                cos: radicalCosine(t),
            });
        }

        const minHandPositions = [];
        for (let min = 0; min < 60; min++) {
            const t = (min / 60) * 4;
            minHandPositions.push({
                sin: radicalSine(t),
                cos: radicalCosine(t),
            });
        }

        const hrHandPositions = [];
        for (let hr = 0; hr < 12; hr++) {
            const t = (hr / 12) * 4;
            hrHandPositions.push({
                sin: radicalSine(t),
                cos: radicalCosine(t),
            });
        }
        function hideControls() {
            var contentElement = document.getElementById("controlsContainer");
            if (contentElement.style.display === "none") {
                contentElement.style.display = "block"; // Show the element
            } else {
                contentElement.style.display = "none"; // Hide the element
            }
        }
        // === Draw background once ===
        function drawStaticBackground() {
            ctx.save();
            const colors = getThemeColors();
            // Outer circle
            ctx.lineWidth = 3;
            let rgb = colors.parallelRGB;
            ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.stroke();

            // Tick marks
            ctx.lineCap = "round";
            for (let i = 0; i < 60; i++) {
                const {
                    sin,
                    cos
                } = secHandPositions[i];
                const inner = i % 5 === 0 ? radius * 0.85 : radius * 0.93;
                const outer = radius * 0.97;
                ctx.beginPath();
                ctx.moveTo(cx + inner * sin, cy - inner * cos);
                ctx.lineTo(cx + outer * sin, cy - outer * cos);
                ctx.lineWidth = i % 5 === 0 ? 3 : 1;
                ctx.strokeStyle = i % 5 === 0 ? "rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)" : "rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 205)";
                ctx.stroke();
            }
            const rauSinTable = [],
                rauCosTable = [];
            for (let i = 0; i < 360; i++) {
                const t = (i / design);
                rauSinTable.push(radicalSine(t));
                rauCosTable.push(radicalCosine(t));
            }
            ctx.restore();
            for (let i = 0; i < 360; i++) {
                const outerRX = size,
                    outerRY = size,
                    innerRX = size,
                    innerRY = size;
                const next = (i - 1) % 25;
                const s = 0.25,
                    e = 0.25;
                const sx = cx + rauSinTable[next] * innerRX * s;
                const sy = cy - rauCosTable[next] * innerRY * s;
                const ex = cx + rauSinTable[i] * innerRX * e;
                const ey = cy - rauCosTable[i] * innerRY * e;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
                ctx.lineWidth = opacity;
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawHand(len, sin, cos, color, width) {
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + len * sin, cy - len * cos);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = "round";
            ctx.stroke();
        }

        // === Animation ===
        const startMillis = new Date().getSeconds() * 1000 + new Date().getMilliseconds();
        let startTime = performance.now() - startMillis;

        function animate(timestamp) {
            const now = new Date();
            const elapsed = (timestamp - startTime) / 1000;

            // Second hand: smooth interpolation
            const secondsFrac = elapsed % 60;
            const sec = Math.floor(secondsFrac);
            const nextSec = (sec + 1) % 60;
            const secFrac = secondsFrac - sec;
            const secPos = interpolate(secHandPositions[sec], secHandPositions[nextSec], secFrac);

            // Minute hand: interpolate within 60 positions
            const totalSeconds = now.getMinutes() * 60 + now.getSeconds();
            const minIndex = Math.floor((totalSeconds / 3600) * 60);
            const minFrac = ((totalSeconds / 3600) * 60) - minIndex;
            const minPos = interpolate(minHandPositions[minIndex % 60], minHandPositions[(minIndex + 1) % 60], minFrac);

            // Hour hand: interpolate within 12 positions
            const totalMinutes = (now.getHours() % 12) * 60 + now.getMinutes();
            const hrIndexFloat = (totalMinutes / 720) * 12; // 0-12 over 12 hours
            const hrIndex = Math.floor(hrIndexFloat) % 12;
            const hrFrac = hrIndexFloat - Math.floor(hrIndexFloat);
            const hrPos = interpolate(hrHandPositions[hrIndex], hrHandPositions[(hrIndex + 1) % 12], hrFrac);

            // Draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStaticBackground();

            drawHand(radius * 0.97, secPos.sin, secPos.cos, "red", 3);
            drawHand(radius * 0.6, minPos.sin, minPos.cos, "blue", 4);
            drawHand(radius * 0.2, hrPos.sin, hrPos.cos, "green", 6);
	        controls.design.value = design;
		  	controls.opacity.value = opacity;
		  	controls.size.value = size;
		  	values.designVal.textContent 	= design;
		  	values.opacityVal.textContent 	= opacity;
		  	values.sizeVal.textContent 		= size;
            requestAnimationFrame(animate);
        }

        function interpolate(p1, p2, t) {
            return {
                sin: p1.sin + (p2.sin - p1.sin) * t,
                cos: p1.cos + (p2.cos - p1.cos) * t
            };
        }
		
        // Start clock
        //drawStaticBackground(); // draw static elements before animation
        requestAnimationFrame(animate);

		Object.keys(controls).forEach(key => {
		  controls[key].addEventListener('input', (e) => {
		    if (key === 'design') design = parseInt(e.target.value);
		    if (key === 'opacity') opacity = parseFloat(e.target.value);
		    if (key === 'size') size = parseInt(e.target.value);
		  });
		});  
    </script>
</body>

</html>
