<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clock Widget</title>
    <link href="css/style_perspective_sphere.css" rel="stylesheet" type="text/css">
</head>

<body>
    <button type="button" data-theme-toggle aria-label="Change Theme">Dark/Light</button>
    <button id="toggleCtrls" onclick="hideControls();">Toggle Controls</button>
    <div id="controlsContainer">
        <div class="controls">
            <div class="control-group">
                <input type="range" min="1" max="100" value="25" class="slider" id="design" step="1">
                üí†<span class="value" id="designVal">25</span>
            </div>
            <div class="control-group">
                <input type="range" min="0.1" max="5" value="0.5" class="slider" id="opacity" step="0.1">
                ëóä<span class="value" id="opacityVal">0.5</span>
            </div>
            <div class="control-group">
                <input type="range" min="50" max="1500" value="1500" class="slider" id="size" step="50">
                üîç<span class="value" id="sizeVal">1500</span>
            </div>
            <div class="control-group">
            	<label>Diagonal Mode</label>
                <input type="checkbox" value="true" id="diagonalMode">
            </div>
        </div>
    </div>
    <canvas id="rauClock" width="750" height="750" style="background: transparent; --canvas-border: transparent;"></canvas>
    <script src="js/rau.js"></script>
    <script>
        // ======================
        // Setup light/dark theme
        // ======================
        (function() {
            const theme = localStorage.getItem("theme") || "dark";
            document.documentElement.dataset.theme = theme;
        })();

        function calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        }) {
            if (localStorageTheme !== null) {
                return localStorageTheme;
            }

            if (systemSettingDark.matches) {
                return "dark";
            }

            return "light";
        }

        const localStorageTheme = "dark";
        const systemSettingDark = window.matchMedia("(prefers-color-scheme: dark)");
        let currentThemeSetting = calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        });

        const button = document.querySelector("[data-theme-toggle]");

        button.addEventListener("click", () => {
            const newTheme = currentThemeSetting === "dark" ? "light" : "dark";
            const newCta = newTheme === "dark" ? "Switch to Light" : "Switch to Dark";
            button.innerText = newCta;
            button.setAttribute("aria-label", newCta);
            document.querySelector("html").setAttribute("data-theme", newTheme);
            localStorage.setItem("theme", newTheme);
            currentThemeSetting = newTheme;
            drawStaticBackgroundOnce();
        });

        function getThemeColors() {
            const theme = localStorage.getItem("theme") || "dark";

            if (theme === "light") {
                return {
                    meridianRGB: [92, 74, 61],
                    parallelRGB: [201, 181, 160],
                    fieldLineRGB: [139, 0, 0]
                };
            } else {
                return {
                    meridianRGB: [0, 255, 136],
                    parallelRGB: [136, 136, 255],
                    fieldLineRGB: [255, 255, 255]
                };
            }
        }

        // ======================
        // Set up for main canvas
        // ======================
        const canvas = document.getElementById("rauClock");
        const ctx = canvas.getContext("2d");
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = Math.min(cx, cy) * 0.9;

        // ===============================
        // Get the values from the sliders
        // ===============================
        const controls = {
            design: document.getElementById('design'),
            opacity: document.getElementById('opacity'),
            size: document.getElementById('size')
        };

        const values = {
            designVal: document.getElementById('designVal'),
            opacityVal: document.getElementById('opacityVal'),
            sizeVal: document.getElementById('sizeVal')
        };

        let design = parseInt(controls.design.value);
        let opacity = parseFloat(controls.opacity.value);
        let size = parseInt(controls.size.value);

        function hideControls() {
            const contentElement = document.getElementById("controlsContainer");
            if (contentElement.style.display === "none") {
                contentElement.style.display = "block";
            } else {
                contentElement.style.display = "none";
            }
        }
        // ======================================================================================        
        // Create a static buffer for the background that gets called from outside animating loop
        // ======================================================================================
        const staticBuffer = document.createElement("canvas");
        staticBuffer.width = canvas.width;
        staticBuffer.height = canvas.height;
        const staticCtx = staticBuffer.getContext("2d");
        
        // =======================================
        // RAU parameter t ‚Üí (x,y) along diagonals
        // =======================================
        function rauToXY(t) {
          const q = Math.floor(t) % 4;
          const lt = t - q; // local parameter in [0,1)
          switch (q) {
            case 0: return { cos: 1 - lt,  sin: lt };      // (1,0) ‚Üí (0,1)
            case 1: return { cos: -lt,     sin: 1 - lt };     // (0,1) ‚Üí (-1,0)
            case 2: return { cos: -1 + lt, sin: -lt };    // (-1,0) ‚Üí (0,-1)
            case 3: return { cos: lt,      sin: -1 + lt };     // (0,-1) ‚Üí (1,0)
          }
        }
        
        // =================================
        // Uniform Velocity Table Generation
        // =================================
        function generateUniformVelocityTable(divisions = 60) {
            const table = [];

            for (let i = 0; i < divisions; i++) {
                // RAU position: uniform steps from 0 to 4
                const rauPosition = (i / divisions) * 4;

                // Compute sin/cos once and store
                const sin = radicalSine(uniformVelocityRAU(rauPosition));
                const cos = radicalCosine(uniformVelocityRAU(rauPosition));

                table.push({ sin, cos, rauPosition });
            }

            return table;
        }

        const uniformVelocityTable = generateUniformVelocityTable(60);

        // ================================
        // Draw Numbered Markers
        // ================================
        function drawNumberedMarkers(ctx, cx, cy, radius, rauTable, color = "white") {
            ctx.save();
            ctx.fillStyle = color;
            ctx.font = "12px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const markerRadius = radius * 0.80;

            for (let i = 0; i < rauTable.length; i += 5) {
                const entry = rauTable[i];
                const sin = entry.sin;
                const cos = entry.cos;

                const x = cx + sin * markerRadius;
                const y = cy - cos * markerRadius;

                ctx.fillText(i.toString(), x, y);
            }

            ctx.restore();
        }
        // ================================
        // Draw Uniform Velocity Ticks
        // ================================
        function drawUniformVelocityTicks(ctx, cx, cy, radius, rauTable, opacity = 0.5, color = "rgba(255, 255, 255, ") {
            ctx.save();

            const tickRadius = radius * 0.92;
            const tickLength = radius * 0.08;

            rauTable.forEach((entry, index) => {
                const sin = entry.sin;
                const cos = entry.cos;

                const innerX = cx + sin * tickRadius;
                const innerY = cy - cos * tickRadius;
                const outerX = cx + sin * (tickRadius + tickLength);
                const outerY = cy - cos * (tickRadius + tickLength);

                ctx.beginPath();
                ctx.moveTo(innerX, innerY);
                ctx.lineTo(outerX, outerY);

                if (index % 5 === 0) {
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = `${color}1.0)`;
                } else {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = `${color}${opacity})`;
                }

                ctx.lineCap = "round";
                ctx.stroke();
            });

            ctx.restore();
        }

        // ================================
        // Draw Numbered Markers
        // ================================
        function drawNumberedMarkers(ctx, cx, cy, radius, rauTable, color = "white") {
            ctx.save();
            ctx.fillStyle = color;
            ctx.font = "14px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const markerRadius = radius * 0.80;
			const indexTransforms = {
			  0: (n) => 12,           // 0 ‚Üí 12
			  5: (n) => n / 5,        // 5 ‚Üí 1
			  10: (n) => n / 5,       // 10 ‚Üí 2
			  3: (n) => n,            // 3 ‚Üí 3
			  8: (n) => n / 2,        // 8 ‚Üí 4
			  1: (n) => n + 4,        // 1 ‚Üí 5
			  6: (n) => n,            // 6 ‚Üí 6
			  11: (n) => n - 4,       // 11 ‚Üí 7
			  4: (n) => n * 2,        // 4 ‚Üí 8
			  9: (n) => n,            // 9 ‚Üí 9
			  2: (n) => n * 5,        // 2 ‚Üí 10
			  7: (n) => n + 4         // 7 ‚Üí 11
			};
			
			for (let i = 0; i < rauTable.length; i += 5) {
			  const entry = rauTable[i];
			  const sin = entry.sin;
			  const cos = entry.cos;
			  const x = cx + sin * markerRadius;
			  const y = cy - cos * markerRadius;
			  
			  const indexPos = i % 12;  // Get the actual index value
			  const transformedNum = Math.round(indexTransforms[indexPos]?.(indexPos) ?? indexPos);
			  const yMinOffset = i >=0 && i < 15 ? -20 : i >= 15 && i <= 30 ? 20 : i > 30 && i <= 45 ?  20 : i > 45  ? -20 : 0;
			  const xMinOffset = i >=0 && i < 15 ? 20 : i >= 15 && i <= 30 ? 20 : i > 30 && i <= 45 ? -20 : i > 45  ? -30 : 0;
			  ctx.fillText(transformedNum.toString(), x, y);
			  ctx.fillText(i.toString(), x + xMinOffset, y + yMinOffset);
			}

            ctx.restore();
        }
        
        // ================================
        // Draw Static Background
        // ================================
        function drawStaticBackgroundOnce() {
            staticCtx.clearRect(0, 0, staticBuffer.width, staticBuffer.height);

            staticCtx.save();
            const colors = getThemeColors();
            const rgb = colors.parallelRGB;

            // Outer circle
            staticCtx.lineWidth = 3;
            staticCtx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
            staticCtx.beginPath();
            staticCtx.arc(cx, cy, radius, 0, 2 * Math.PI);
            staticCtx.stroke();

            // Center dot
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(cx, cy, 6, 0, 2 * Math.PI);
            ctx.fill();

            // Uniform velocity ticks
            drawUniformVelocityTicks(staticCtx, cx, cy, radius, uniformVelocityTable, 0.6, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, `);

            // Numbered markers
            drawNumberedMarkers(staticCtx, cx, cy, radius, uniformVelocityTable, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.8)`);

            staticCtx.lineCap = "round";

            // Fancy inner pattern
            const rauSinTable = [];
            const rauCosTable = [];
            for (let i = 0; i < 360; i++) {
                const t = (i / design);
                rauSinTable.push(radicalSine(t));
                rauCosTable.push(radicalCosine(t));
            }

            for (let i = 0; i < 360; i++) {
                const outerRX = size;
                const outerRY = size;
                const innerRX = size;
                const innerRY = size;
                const next = (i - 1) % 25;
                const s = 0.25;
                const e = 0.25;
                const sx = cx + rauSinTable[next] * innerRX * s;
                const sy = cy - rauCosTable[next] * innerRY * s;
                const ex = cx + rauSinTable[i] * innerRX * e;
                const ey = cy - rauCosTable[i] * innerRY * e;
                staticCtx.beginPath();
                staticCtx.moveTo(sx, sy);
                staticCtx.lineTo(ex, ey);
                staticCtx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
                staticCtx.lineWidth = opacity;
                staticCtx.stroke();
            }

            staticCtx.restore();
        }
        
		// Helper function
        function drawHand(len, sin, cos, color, width) {
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + len * sin, cy - len * cos);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = "round";
            ctx.stroke();
        }

        // ================================
        // Uniform Velocity Conversion (tan-based)
        // ================================
        function uniformVelocityRAU(linearParam) {
            // Map linear parameter to uniform velocity RAU
            // This compensates for the non-linear speed of RAU functions
            const phase = linearParam % 4;
            const quadrant = Math.floor(phase);
            const t = phase - quadrant; // 0 to 1 within quadrant
            // Return adjusted RAU parameter
            return quadrant + uniformRAU(t);
        }

        // ================================
        // Main function for the frame loop
        // ================================
        function animate() {
            const now = new Date();

            // Continuous time fractions
            const secFrac = (now.getSeconds() + now.getMilliseconds() / 1000) / 60;
            const minFrac = (now.getMinutes() + secFrac) / 60;
            const hrFrac = ((now.getHours() % 12) + minFrac) / 12;
			
            // Convert to a uniform velocity parameter
			const rauSec = uniformVelocityRAU(secFrac * 4);
            const rauMin = uniformVelocityRAU(minFrac * 4);
            const rauHr = uniformVelocityRAU(hrFrac * 4);

            // Evaluate radical trig functions
            let sec = {sin: 0, cos: 0};
            if (document.getElementById('diagonalMode').checked) {
   				sec = rauToXY(uniformVelocityRAU(secFrac * 4));
            }
            else {
            	sec = {
                	sin: radicalSine(rauSec),
                	cos: radicalCosine(rauSec)
            	};
           	}
            const min = {
                sin: radicalSine(rauMin),
                cos: radicalCosine(rauMin)
            };
            const hr = {
                sin: radicalSine(rauHr),
                cos: radicalCosine(rauHr)
            };
            
            // Draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
			// The background (cached)
            ctx.drawImage(staticBuffer, 0, 0);
			// Hands
            drawHand(radius * 0.95, sec.sin, sec.cos, "red", 2);		
            drawHand(radius * 0.6, min.sin, min.cos, "blue", 3);
            drawHand(radius * 0.4, hr.sin, hr.cos, "green", 4);

            values.designVal.textContent = design;
            values.opacityVal.textContent = opacity;
            values.sizeVal.textContent = size;
            requestAnimationFrame(animate);
        }

        // Start clock
        drawStaticBackgroundOnce();
        requestAnimationFrame(animate);
		
        Object.keys(controls).forEach(key => {
            controls[key].addEventListener('input', (e) => {
                if (key === 'design') {
                    design = parseInt(e.target.value);
                    drawStaticBackgroundOnce();
                }
                if (key === 'opacity') {
                    opacity = parseFloat(e.target.value);
                    drawStaticBackgroundOnce();
                }
                if (key === 'size') {
                    size = parseInt(e.target.value);
                    drawStaticBackgroundOnce();
                }
            });
        });
    </script>
</body>

</html>
