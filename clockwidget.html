<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clock Widget</title>
    <link href="css/style_perspective_sphere.css" rel="stylesheet" type="text/css">
</head>

<body>
    <button type="button" data-theme-toggle aria-label="Change Theme">Dark/Light</button>
    <button id="toggleCtrls" onclick="hideControls();">Toggle Controls</button>
    <div id="controlsContainer">
	<div class="controls">
        <div class="control-group">
        <input type="range" min="1" max="100" value="25" class="slider" id="design" step="1">
        üí†<span class="value" id="designVal">25</span>
        </div>
        <div class="control-group">
        <input type="range" min="0.1" max="5" value="0.5" class="slider" id="opacity" step="0.1">
        ëóä<span class="value" id="opacityVal">0.5</span>
        </div>
        <div class="control-group">
        <input type="range" min="50" max="1000" value="1000" class="slider" id="size" step="50">
        üîç<span class="value" id="sizeVal">1000</span>
        </div>
	</div>
    </div>
    <canvas id="rauClock" width="750" height="750" style="background: transparent; --canvas-border: transparent;">></canvas>
    <script src="js/rau.js"></script>
    <script>
        (function() {
            const theme = localStorage.getItem("theme") || "dark"; // default
            document.documentElement.dataset.theme = theme;
        })();
        function calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        }) {
            if (localStorageTheme !== null) {
                return localStorageTheme;
            }

            if (systemSettingDark.matches) {
                return "dark";
            }

            return "light";
        }

        const localStorageTheme = "dark";
        const systemSettingDark = window.matchMedia("(prefers-color-scheme: dark)");
        let currentThemeSetting = calculateSettingAsThemeString({
            localStorageTheme,
            systemSettingDark
        });
        // target the button using the data attribute we added earlier
        const button = document.querySelector("[data-theme-toggle]");

        button.addEventListener("click", () => {
            const newTheme = currentThemeSetting === "dark" ? "light" : "dark";

            // update the button text
            const newCta = newTheme === "dark" ? "Switch to Light" : "Switch to Dark";
            button.innerText = newCta;

            // use an aria-label if you are omitting text on the button
            // and using sun/moon icons, for example
            button.setAttribute("aria-label", newCta);

            // update theme attribute on HTML to switch theme in CSS
            document.querySelector("html").setAttribute("data-theme", newTheme);

            // update in local storage
            localStorage.setItem("theme", newTheme);
			
            // update the currentThemeSetting in memory
            currentThemeSetting = newTheme;
            // Redraw the static layer with the new colors
            drawStaticBackgroundOnce();
        });
        const themeBtn = document.querySelector('button[data-theme-toggle]');
		function applyCanvasTheme() {
		  const root = document.documentElement;
		  const styles = getComputedStyle(root);
		  const bgColor = styles.getPropertyValue('--bg-color').trim();

		  // Main visible canvas
		  canvas.style.backgroundColor = bgColor;

		  // Static buffer canvas (offscreen)
		  staticCtx.fillStyle = bgColor;
		  staticCtx.fillRect(0, 0, staticBuffer.width, staticBuffer.height);
		}
        function getThemeColors() {
            const theme = localStorage.getItem("theme") || "dark";

            if (theme === "light") {
                return {
                    meridianRGB: [92, 74, 61], // Brown RGB values
                    parallelRGB: [201, 181, 160], // Beige RGB values
                    fieldLineRGB: [139, 0, 0] // Deep red RGB values
                };
            } else {
                return {
                    meridianRGB: [0, 255, 136], // Green RGB values
                    parallelRGB: [136, 136, 255], // Blue RGB values
                    fieldLineRGB: [255, 255, 255] // White RGB values
                };
            }
        }
        const canvas = document.getElementById("rauClock");
        const ctx = canvas.getContext("2d");
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = Math.min(cx, cy) * 0.9;
		let colors = getThemeColors();
		let rgb = colors.parallelRGB;
		// Control elements
		const controls = {
		    design: document.getElementById('design'),
		    opacity: document.getElementById('opacity'),
		    size: document.getElementById('size')
		};
        const values = {
		    designVal: document.getElementById('designVal'),
            opacityVal: document.getElementById('opacityVal'),
            sizeVal: document.getElementById('sizeVal')
        };
        let design   = parseInt(controls.design.value);
       	let opacity  = parseFloat(controls.opacity.value);
        let size 	 = parseInt(controls.size.value);
        
        const sinTable = [], cosTable = [];
        for (let deg = 0; deg < 360; deg += 6) {
          const rad = deg * Math.PI / 180;
          sinTable.push(Math.sin(rad));
          cosTable.push(Math.cos(rad));
        }
        
        function hideControls() {
            var contentElement = document.getElementById("controlsContainer");
            if (contentElement.style.display === "none") {
                contentElement.style.display = "block"; // Show the element
            } else {
                contentElement.style.display = "none"; // Hide the element
            }
        }
        // Create offscreen canvas for static background
        const staticBuffer = document.createElement("canvas");
        staticBuffer.width = canvas.width;
        staticBuffer.height = canvas.height;
        const staticCtx = staticBuffer.getContext("2d");
        
		// === Draw background once ===
        function drawStaticBackgroundOnce() {
            staticCtx.clearRect(0, 0, staticBuffer.width, staticBuffer.height);
        
            // Apply theme-based background
            applyCanvasTheme();
        
            const colors = getThemeColors();
            const rgb = colors.parallelRGB;
            staticCtx.save();
            
            // Outer circle
            staticCtx.lineWidth = 3;
            
            staticCtx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
            staticCtx.clearRect(0, 0, staticBuffer.width, staticBuffer.height);
            staticCtx.beginPath();
            staticCtx.arc(cx, cy, radius, 0, 2 * Math.PI);
            staticCtx.stroke();

            // Tick marks
            staticCtx.lineCap = "round";
            for (let i = 0; i < 60; i++) {
                const inner = i % 5 === 0 ? radius * 0.85 : radius * 0.93;
                const outer = radius * 0.97;
                staticCtx.beginPath();
                staticCtx.moveTo(cx + inner * sinTable[i], cy - inner * cosTable[i]);
                staticCtx.lineTo(cx + outer * sinTable[i], cy - outer * cosTable[i]);
                staticCtx.lineWidth = i % 5 === 0 ? 3 : 1;
                staticCtx.strokeStyle = i % 5 === 0 ? "rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)" : "rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 205)";
                staticCtx.stroke();
            }
            
            const rauSinTable = [],
                rauCosTable = [];
            for (let i = 0; i < 360; i++) {
                const t = (i / design);
                rauSinTable.push(radicalSine(t));
                rauCosTable.push(radicalCosine(t));
            }
            staticCtx.restore();
            for (let i = 0; i < 360; i++) {
                const outerRX = size,
                    outerRY = size,
                    innerRX = size,
                    innerRY = size;
                const next = (i - 1) % 25;
                const s = 0.25,
                    e = 0.25;
                const sx = cx + rauSinTable[next] * innerRX * s;
                const sy = cy - rauCosTable[next] * innerRY * s;
                const ex = cx + rauSinTable[i] * innerRX * e;
                const ey = cy - rauCosTable[i] * innerRY * e;
                staticCtx.beginPath();
                staticCtx.moveTo(sx, sy);
                staticCtx.lineTo(ex, ey);
                staticCtx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 255)`;
                staticCtx.lineWidth = opacity;
                staticCtx.stroke();
            }
            staticCtx.restore();
        }

        function drawHand(len, sin, cos, color, width) {
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + len * sin, cy - len * cos);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = "round";
            ctx.stroke();
        }

        // === Animation ===
        function animate() {
        
          // Parameters
          const now = new Date();
          const startMillis = new Date().getSeconds() * 1000 + new Date().getMilliseconds();
          let startTime = performance.now() - startMillis;
  
          const elapsed = (performance.now() - startTime) / 1000;
          const secFrac = (elapsed % 60) / 60;  // 0‚Äì1 over 60 sec
          const totalSeconds = now.getMinutes() * 60 + now.getSeconds();
          const minFrac = totalSeconds / 3600;  // 0‚Äì1 over 60 minutes
          const totalMinutes = (now.getHours() % 12) * 60 + now.getMinutes();
          const hrFrac = totalMinutes / 720;  // 0‚Äì1 over 12 hours
          // --- seconds hand (full revolution in 60 seconds)
          const secIndexFloat = secFrac * sinTable.length;
          const secIndex = Math.floor(secIndexFloat);
          const secNext = (secIndex + 1) % sinTable.length;
          const fracSec = secIndexFloat - secIndex;
        
          const sinValSec = sinTable[secIndex] + (sinTable[secNext] - sinTable[secIndex]) * fracSec;
          const cosValSec = cosTable[secIndex] + (cosTable[secNext] - cosTable[secIndex]) * fracSec;
        
          // --- minute hand (full revolution in 60 minutes)
          const minIndexFloat = minFrac * sinTable.length;
          const minIndex = Math.floor(minIndexFloat);
          const minNext = (minIndex + 1) % sinTable.length;
          const fracMin = minIndexFloat - minIndex;
        
          const sinValMin = sinTable[minIndex] + (sinTable[minNext] - sinTable[minIndex]) * fracMin;
          const cosValMin = cosTable[minIndex] + (cosTable[minNext] - cosTable[minIndex]) * fracMin;
        
          // --- hour hand (full revolution in 12 hours)
          const hrIndexFloat = hrFrac * sinTable.length;
          const hrIndex = Math.floor(hrIndexFloat);
          const hrNext = (hrIndex + 1) % sinTable.length;
          const fracHr = hrIndexFloat - hrIndex;
        
          const sinValHr = sinTable[hrIndex] + (sinTable[hrNext] - sinTable[hrIndex]) * fracHr;
          const cosValHr = cosTable[hrIndex] + (cosTable[hrNext] - cosTable[hrIndex]) * fracHr;
        
          // --- drawing
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(staticBuffer, 0, 0);
        
          drawHand(radius * 0.97, sinValSec, cosValSec, "red", 3);
          drawHand(radius * 0.6,  sinValMin, cosValMin, "blue", 4);
          drawHand(radius * 0.2,  sinValHr,  cosValHr,  "green", 6);
        
          // Update UI values
          values.designVal.textContent = design;
          values.opacityVal.textContent = opacity;
          values.sizeVal.textContent = size;
        
          requestAnimationFrame(animate);
        }
        
        function interpolate(p1, p2, t) {
            return {
                sin: p1.sin + (p2.sin - p1.sin) * t,
                cos: p1.cos + (p2.cos - p1.cos) * t
            };
        }
		
        // Start clock (only once, before the hands are drawn for the ongoing frames in time)
        drawStaticBackgroundOnce(); // Draw static art one time
        requestAnimationFrame(animate);
        
		
		Object.keys(controls).forEach(key => {
		  controls[key].addEventListener('input', (e) => {
		    if (key === 'design') {
		    	design = parseInt(e.target.value);
		    	drawStaticBackgroundOnce();
	    	}
		    if (key === 'opacity') {
		    	opacity = parseFloat(e.target.value);
		    	drawStaticBackgroundOnce();
	    	}
		    if (key === 'size') {
		    	size = parseInt(e.target.value);
		    	drawStaticBackgroundOnce();
	    	}
		  });
		});  
    </script>
</body>

</html>
