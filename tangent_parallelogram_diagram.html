<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vector + RAU Angle Visualization</title>
<style>
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #f0f0f0;
}
.container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    padding: 20px;
    gap: 20px;
}
canvas {
    border: 2px solid #333;
    background: white;
    border-radius: 8px;
}
.controls, .results {
    width: 380px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.control-group {
    display: flex;
    align-items: center;
    margin: 10px 0;
}
label {
    min-width: 120px;
    font-weight: bold;
}
input[type="range"] {
    flex: 1;
    margin: 0 10px;
}
.value {
    width: 50px;
    text-align: right;
    font-family: monospace;
}
.results pre {
    font-family: 'Courier New', monospace;
}
</style>
</head>
<body>
<div class="container">
    <canvas id="canvas" width="600" height="500"></canvas>
    
    <div class="controls">
        <h3>Vector Controls</h3>
        <div class="control-group">
            <label>u length:</label>
            <input type="range" id="uLength" min="50" max="200" value="120">
            <span class="value" id="uLengthVal">120</span>
        </div>
        <div class="control-group">
            <label>u angle (°):</label>
            <input type="range" id="uAngle" min="0" max="360" value="30">
            <span class="value" id="uAngleVal">30°</span>
        </div>
        <div class="control-group">
            <label>v length:</label>
            <input type="range" id="vLength" min="50" max="200" value="100">
            <span class="value" id="vLengthVal">100</span>
        </div>
        <div class="control-group">
            <label>v angle (°):</label>
            <input type="range" id="vAngle" min="0" max="360" value="0">
            <span class="value" id="vAngleVal">0°</span>
        </div>

        <div class="results">
        <h3>Computation Results</h3>
        <pre id="resultsContent">Vector Information:
    u = (  103.92,   -60.00)
    v = (  100.00,     0.00)
    Cross =  6000.00, Dot = 10392.30
    
    Traditional Angle:
    θ =    0.524 rad |   30.0°
    tan(θ) =   0.5774
    
    RAU / Radical Angle:
    Phase =      0.333 (0–4)
    radicalSine   =    0.447
    radicalCosine =    0.894
    θ =    0.524 rad |   30.0°</pre>
    </div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const centerX = canvas.width/2;
const centerY = canvas.height/2;

const controls = {
    uLength: document.getElementById('uLength'),
    uAngle: document.getElementById('uAngle'),
    vLength: document.getElementById('vLength'),
    vAngle: document.getElementById('vAngle')
};
const displays = {
    uLengthVal: document.getElementById('uLengthVal'),
    uAngleVal: document.getElementById('uAngleVal'),
    vLengthVal: document.getElementById('vLengthVal'),
    vAngleVal: document.getElementById('vAngleVal'),
    resultsContent: document.getElementById('resultsContent')
};

function degToRad(deg) { return deg * Math.PI/180; }
function radToDeg(rad) { return rad*180/Math.PI; }

function drawArrow(ctx, fromX, fromY, toX, toY, color, width=2){
    const headLen=12;
    const dx=toX-fromX, dy=toY-fromY;
    const angle=Math.atan2(dy,dx);
    ctx.strokeStyle=color;
    ctx.lineWidth=width;
    ctx.beginPath();
    ctx.moveTo(fromX,fromY);
    ctx.lineTo(toX,toY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(toX,toY);
    ctx.lineTo(toX-headLen*Math.cos(angle-Math.PI/6),toY-headLen*Math.sin(angle-Math.PI/6));
    ctx.moveTo(toX,toY);
    ctx.lineTo(toX-headLen*Math.cos(angle+Math.PI/6),toY-headLen*Math.sin(angle+Math.PI/6));
    ctx.stroke();
}

function drawText(ctx,text,x,y,color='black',font='14px Arial'){
    ctx.fillStyle=color;
    ctx.font=font;
    ctx.fillText(text,x,y);
}

function drawGrid(ctx,width,height,scale=50){
    ctx.strokeStyle='#ddd';
    ctx.lineWidth=1;
    for(let i=-Math.floor(width/scale);i<=Math.floor(width/scale);i++){
        ctx.beginPath();
        ctx.moveTo(centerX+i*scale,0);
        ctx.lineTo(centerX+i*scale,height);
        ctx.stroke();
    }
    for(let j=-Math.floor(height/scale);j<=Math.floor(height/scale);j++){
        ctx.beginPath();
        ctx.moveTo(0,centerY+j*scale);
        ctx.lineTo(width,centerY+j*scale);
        ctx.stroke();
    }
    // axes
    ctx.strokeStyle='#666';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(centerX,0); ctx.lineTo(centerX,height);
    ctx.moveTo(0,centerY); ctx.lineTo(width,centerY);
    ctx.stroke();
}

function shadeQuadrant(ctx,uEnd,vEnd){
    ctx.fillStyle='rgba(200,200,255,0.1)';
    ctx.beginPath();
    ctx.moveTo(centerX,centerY);
    ctx.lineTo(uEnd.x,uEnd.y);
    ctx.lineTo(vEnd.x,vEnd.y);
    ctx.closePath();
    ctx.fill();
}

// --- RAU radical sine & cosine ---
function radicalSine(t){
    t = t % 4;
    const quadrant = Math.floor(t);
    const lt = t - quadrant;
    const a = 1 - 2*lt + 2*lt*lt;
    switch(quadrant){
        case 0: return lt/Math.sqrt(a);
        case 1: return (1-lt)/Math.sqrt(a);
        case 2: return -lt/Math.sqrt(a);
        case 3: return -(1-lt)/Math.sqrt(a);
    }
}

function radicalCosine(t){
    t = t % 4;
    const quadrant = Math.floor(t);
    const lt = t - quadrant;
    const a = 1 - 2*lt + 2*lt*lt;
    switch(quadrant){
        case 0: return (1-lt)/Math.sqrt(a);
        case 1: return -lt/Math.sqrt(a);
        case 2: return -(1-lt)/Math.sqrt(a);
        case 3: return lt/Math.sqrt(a);
    }
}

// --- Compute RAU phase from two vectors (0-4) ---
function computeRAUPhase(u,v){
    const dot = u.x*v.x + u.y*v.y;
    const cross = u.x*v.y - u.y*v.x;
    if(dot === 0 && cross === 0) return 0;
    let angle = Math.atan2(cross, dot);
    if(angle < 0) angle += 2*Math.PI;
    return (angle/(2*Math.PI))*4;
}

// --- Compute traditional angle 0→2π ---
function vectorAngle(u,v){
    const angle = Math.atan2(v.y,v.x) - Math.atan2(u.y,u.x);
    return (angle + 2*Math.PI) % (2*Math.PI);
}

function drawChordConnection(ctx, u, v, radius) {
    // Normalize vectors to unit circle
    const uNorm = {x: u.x / Math.sqrt(u.x*u.x + u.y*u.y), 
                   y: u.y / Math.sqrt(u.x*u.x + u.y*u.y)};
    const vNorm = {x: v.x / Math.sqrt(v.x*v.x + v.y*v.y), 
                   y: v.y / Math.sqrt(v.x*v.x + v.y*v.y)};
    
    // Draw theoretical circle
    ctx.strokeStyle = 'rgba(100, 200, 100, 0.3)';
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Triangle vertices
    const O = {x: centerX, y: centerY};
    const B = {x: centerX + radius * uNorm.x, y: centerY + radius * uNorm.y};
    const A = {x: centerX + radius * vNorm.x, y: centerY + radius * vNorm.y};
    
    // Midpoint M (for mirror line)
    const M = {x: (O.x + A.x) / 2, y: (O.y + A.y) / 2};
    
    // Draw triangle
    ctx.strokeStyle = 'rgba(0, 150, 0, 0.5)';
    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(O.x, O.y);
    ctx.lineTo(B.x, B.y);
    ctx.lineTo(A.x, A.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Draw mirror line (vertical through M)
    ctx.strokeStyle = 'rgba(0, 150, 0, 0.3)';
    ctx.setLineDash([3, 3]);
    ctx.beginPath();
    ctx.moveTo(M.x, M.y - 50);
    ctx.lineTo(M.x, M.y + 50);
    ctx.stroke();
    ctx.setLineDash([]);

    // label chord length
    const chordLen = Math.hypot(A.x - B.x, A.y - B.y);
    //drawText(ctx, `Chord = ${chordLen.toFixed(1)}`, (A.x+B.x)/2 + 10, (A.y+B.y)/2, '#060', '12px monospace');
    
    // mark the arc endpoints
    ctx.fillStyle = '#060';
    ctx.beginPath(); ctx.arc(A.x, A.y, 3, 0, 2*Math.PI); ctx.fill();
    ctx.beginPath(); ctx.arc(B.x, B.y, 3, 0, 2*Math.PI); ctx.fill();
}

function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawGrid(ctx,canvas.width,canvas.height,50);

    const uLen = parseInt(controls.uLength.value);
    const uAng = degToRad(parseInt(controls.uAngle.value));
    const vLen = parseInt(controls.vLength.value);
    const vAng = degToRad(parseInt(controls.vAngle.value));

    displays.uLengthVal.textContent = uLen;
    displays.uAngleVal.textContent = radToDeg(uAng).toFixed(0)+'°';
    displays.vLengthVal.textContent = vLen;
    displays.vAngleVal.textContent = radToDeg(vAng).toFixed(0)+'°';

    const u={x:uLen*Math.cos(uAng), y:-uLen*Math.sin(uAng)};
    const v={x:vLen*Math.cos(vAng), y:-vLen*Math.sin(vAng)};

    const uEnd={x:centerX+u.x, y:centerY+u.y};
    const vEnd={x:centerX+v.x, y:centerY+v.y};
    const para={x:centerX+u.x+v.x, y:centerY+u.y+v.y};

    // lightly shade quadrant
    shadeQuadrant(ctx,uEnd,vEnd);

    // parallelogram
    ctx.strokeStyle='#aaa';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(centerX,centerY);
    ctx.lineTo(uEnd.x,uEnd.y);
    ctx.lineTo(para.x,para.y);
    ctx.lineTo(vEnd.x,vEnd.y);
    ctx.closePath();
    ctx.stroke();

    // vectors
    drawArrow(ctx,centerX,centerY,uEnd.x,uEnd.y,'#ff4444',3);
    drawArrow(ctx,centerX,centerY,vEnd.x,vEnd.y,'#4444ff',3);

    // angle arc
    const arcRadius = Math.min(uLen, vLen);
    const startAngle = Math.min(uAng,vAng);
    const endAngle = Math.max(uAng,vAng);
    ctx.strokeStyle='#666';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(centerX,centerY,arcRadius,-endAngle,-startAngle);
    ctx.stroke();
    const midAngle = (startAngle+endAngle)/2;
    const labelX=centerX+(arcRadius+15)*Math.cos(midAngle);
    const labelY=centerY-(arcRadius+15)*Math.sin(midAngle);
    drawText(ctx,'θ',labelX,labelY,'#666','bold 14px Arial');

    // cross, dot
    const cross = u.x*v.y - u.y*v.x;
    const dot = u.x*v.x + u.y*v.y;

    // traditional
    const angleRad = vectorAngle(u,v);
    const angleDeg = radToDeg(angleRad);
    const tangent = dot!==0 ? Math.abs(cross/dot) : Infinity;

    // rau
    const rauPhase = computeRAUPhase(u,v);
    const rauSine = radicalSine(rauPhase);
    const rauCos = radicalCosine(rauPhase);
    const rauRad = Math.atan(Math.abs(cross/dot));
    const rauDeg = radToDeg(rauRad);

    function formatNum(num, width=8, decimals=2){
        return num.toFixed(decimals).padStart(width);
    }
    
    function formatNum(num, width=8, decimals=2){
        return num.toFixed(decimals).padStart(width);
    }
    
    const uXStr = formatNum(u.x);
    const uYStr = formatNum(u.y);
    const vXStr = formatNum(v.x);
    const vYStr = formatNum(v.y);
    const crossStr = formatNum(cross);
    const dotStr = formatNum(dot);
    const angleRadStr = formatNum(angleRad,8,3);
    const angleDegStr = formatNum(angleDeg,6,1);
    const tangentStr = isFinite(tangent) ? formatNum(tangent,8,4) : '    ∞';
    const rauPhaseStr = formatNum(rauPhase,6,3);
    const rauSineStr = formatNum(rauSine,8,3);
    const rauCosStr = formatNum(rauCos,8,3);
    const rauRadStr = formatNum(rauRad,8,3);
    const rauDegStr = formatNum(rauDeg,6,1);
    
    displays.resultsContent.textContent =
    `Vector Information:
    u = (${uXStr}, ${uYStr})
    v = (${vXStr}, ${vYStr})
    Cross = ${crossStr}, Dot = ${dotStr}
    
    Traditional Angle:
    θ = ${angleRadStr} rad | ${angleDegStr}°
    tan(θ) = ${tangentStr}
    
    RAU / Radical Angle:
    Phase =     ${rauPhaseStr} (0–4)
    radicalSine   = ${rauSineStr}
    radicalCosine = ${rauCosStr}
    θ = ${rauRadStr} rad | ${rauDegStr}°`;

    drawChordConnection(ctx, v, u, arcRadius);
}
// event listeners
Object.values(controls).forEach(c=>c.addEventListener('input',render));
render();
</script>
</body></html>
