<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcendental Hyperbolic Shader</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: monospace;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
            color: white;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        label {
            display: inline-block;
            width: 140px;
            font-size: 11px;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        input[type="checkbox"] {
            margin-left: 5px;
        }
        
        .value {
            color: #00ff88;
            font-weight: bold;
            font-size: 11px;
        }
        
        h3 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <div class="controls">
        <h3>Transcendental Hyperbolic Tunnel</h3>
        
        <div class="control-group">
            <label>Show Tunnel:</label>
            <input type="checkbox" id="showTunnel" checked>
        </div>
        
        <div class="control-group">
            <label>Show √2 Circles:</label>
            <input type="checkbox" id="showCircles" checked>
        </div>
        
        <div class="control-group">
            <label>Show Transcendental:</label>
            <input type="checkbox" id="showTranscendental" checked>
        </div>
        
        <div class="control-group">
            <label>Show Grid:</label>
            <input type="checkbox" id="showGrid" checked>
        </div>
        
        <div class="control-group">
            <label>Zoom:</label>
            <input type="range" id="zoom" min="0.5" max="3.0" step="0.1" value="1.0">
            <span class="value" id="zoomVal">1.0</span>
        </div>
        
        <div class="control-group">
            <label>Tunnel Depth:</label>
            <input type="range" id="tunnelDepth" min="10" max="50" step="1" value="30">
            <span class="value" id="tunnelDepthVal">30</span>
        </div>
        
        <div class="control-group">
            <label>Line Thickness:</label>
            <input type="range" id="lineThickness" min="0.5" max="5.0" step="0.1" value="2.0">
            <span class="value" id="lineThicknessVal">2.0</span>
        </div>
        
        <div class="control-group">
            <label>Animate:</label>
            <input type="checkbox" id="animate">
        </div>
        
        <div class="control-group">
            <label>Show UV Tessellation:</label>
            <input type="checkbox" id="showTessellation" value="checked">
        </div>
        
        <div class="control-group">
            <label>Transform Matrix:</label>
        </div>
        <div class="control-group" style="margin-left: 20px;">
            <label style="width: 60px;">Rotation:</label>
            <input type="range" id="matrixRotation" min="0" max="90" step="1" value="0">
            <span class="value" id="matrixRotationVal">0°</span>
        </div>
        <div class="control-group" style="margin-left: 20px;">
            <label style="width: 60px;">Scale:</label>
            <input type="range" id="matrixScale" min="0.5" max="2.0" step="0.1" value="1.0">
            <span class="value" id="matrixScaleVal">1.0</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        // Resize canvas to fill window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
        
        // Fragment shader
        const fragmentShaderSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;
            uniform float zoom;
            uniform float tunnelDepth;
            uniform float lineThickness;
            uniform bool showTunnel;
            uniform bool showCircles;
            uniform bool showTranscendental;
            uniform bool showGrid;
            uniform bool showTessellation;
            uniform mat2 transformMatrix;
            
            #define PI 3.14159265359
            
            // Distance to line segment
            float line(vec2 p, vec2 a, vec2 b) {
                p -= a;
                b -= a;
                float h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);
                return length(p - b * h);
            }
            
            // Distance to circle
            float circle(vec2 p, float r) {
                return abs(length(p) - r);
            }
            
            // Transcendental equation distance field
            float transcendentalDist(vec2 p) {
                if (abs(p.x) < 0.01 || abs(p.y) < 0.01) return 1000.0;
                
                float cosX = cos(PI / p.x);
                float sinY = sin(PI / p.y);
                float val = cosX * cosX + sinY * sinY;
                
                return abs(val - 1.0) * 2.0;
            }
            
            // Convert XY to UV transcendental coordinates
            vec2 xyToUV(vec2 p) {
                if (abs(p.x) < 0.01 || abs(p.y) < 0.01) return vec2(0.0);
                
                float u = pow(cos(PI / p.x), 2.0);
                float v = pow(sin(PI / p.y), 2.0);
                return vec2(u, v);
            }
            
            // Convert UV back to XY (approximate)
            vec2 uvToXY(vec2 uv) {
                float u = clamp(uv.x, 0.01, 0.99);
                float v = clamp(uv.y, 0.01, 0.99);
                
                float x = PI / acos(sqrt(u));
                float y = PI / asin(sqrt(v));
                return vec2(x, y);
            }
            
            // Tessellation in UV space
            float uvTessellation(vec2 p) {
                vec2 uv = xyToUV(p);
                
                // Apply transformation in UV space
                uv = transformMatrix * uv;
                
                // Create grid in UV space
                vec2 gridUV = fract(uv * 10.0);
                gridUV = abs(gridUV - 0.5);
                
                return min(gridUV.x, gridUV.y) * 2.0;
            }
            
            void main() {
                vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;
                uv *= zoom;
                
                vec2 U = abs(9.0 * uv);
                vec2 I = floor(U);
                
                // Apply symmetry
                if (U.y > U.x) U = U.yx;
                
                float d = 1000.0;
                float z = 1.0;
                
                // Hyperbolic tunnel
                if (showTunnel && I.x + I.y < 7.0) {
                    for (int x = 0; x < 4; x++) {
                        // Radial lines
                        d = min(d, line(U, vec2(0.0), vec2(7.0 - float(x), float(x))));
                        d = min(d, line(U, vec2(0.0), vec2(7.0 - float(x), float(x) + 1.0)));
                        
                        // Nested squares with exponential scaling
                        z = 1.0;
                        for (int n = 0; n < 50; n++) {
                            if (float(n) >= tunnelDepth) break;
                            
                            vec2 a = vec2(7.0 - float(x), float(x) + 1.0) / z;
                            vec2 b = vec2(7.0 - float(x), float(x)) / z;
                            vec2 c = vec2(6.0 - float(x), float(x) + 1.0) / z;
                            
                            d = min(d, line(U, a, b));
                            d = min(d, line(U, a, c));
                            
                            z *= 1.13;
                        }
                    }
                    z = 1.5 + 0.5 * (7.0 - U.x - U.y);
                }
                
                // √2 concentric circles
                if (showCircles) {
                    float sqrt2 = 1.41421356237;
                    for (float a = 1.0/6.0; a <= 2.0; a += 1.0/6.0) {
                        float r = sqrt2 * a * 0.8;
                        float circleDist = circle(uv, r);
                        d = min(d, circleDist * 10.0);
                    }
                }
                
                // Transcendental grid
                if (showTranscendental) {
                    float transDist = transcendentalDist(uv);
                    d = min(d, transDist * 5.0);
                }
                
                // UV-space tessellation
                if (showTessellation) {
                    float tessDist = uvTessellation(uv);
                    d = min(d, tessDist);
                }
                
                // Regular grid overlay
                if (showGrid && I.x + I.y >= 7.0) {
                    vec2 gridUV = abs(fract(U - 0.5) - 0.5);
                    d = min(d, min(gridUV.x, gridUV.y));
                }
                
                // Anti-aliased rendering
                float thickness = lineThickness / iResolution.y * 30.0;
                float alpha = 1.0 - smoothstep(0.0, thickness, d) / z;
                
                // Color based on feature
                vec3 color = vec3(0.0);
                
                if (showTunnel && I.x + I.y < 7.0) {
                    color = vec3(0.0, 1.0, 0.5); // Cyan for tunnel
                }
                if (showCircles) {
                    float sqrt2 = 1.41421356237;
                    for (float a = 1.0/6.0; a <= 2.0; a += 1.0/6.0) {
                        float r = sqrt2 * a * 0.8;
                        if (abs(circle(uv, r) * 10.0 - d) < 0.01) {
                            color = vec3(1.0, 0.8, 0.0); // Yellow for circles
                        }
                    }
                }
                if (showTranscendental) {
                    float transDist = transcendentalDist(uv) * 5.0;
                    if (abs(transDist - d) < 0.01) {
                        color = vec3(1.0, 0.0, 1.0); // Magenta for transcendental
                    }
                }
                if (showGrid && I.x + I.y >= 7.0) {
                    color = vec3(0.3, 0.3, 0.5); // Blue-gray for grid
                }
                if (showTessellation) {
                    float tessDist = uvTessellation(uv);
                    if (abs(tessDist - d) < 0.01) {
                        color = vec3(0.0, 1.0, 1.0); // Cyan for UV tessellation
                    }
                }
                
                gl_FragColor = vec4(color * alpha, alpha);
            }
        `;
        
        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        // Set up geometry (fullscreen quad)
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Get uniform locations
        const uniforms = {
            iResolution: gl.getUniformLocation(program, 'iResolution'),
            iTime: gl.getUniformLocation(program, 'iTime'),
            zoom: gl.getUniformLocation(program, 'zoom'),
            tunnelDepth: gl.getUniformLocation(program, 'tunnelDepth'),
            lineThickness: gl.getUniformLocation(program, 'lineThickness'),
            showTunnel: gl.getUniformLocation(program, 'showTunnel'),
            showCircles: gl.getUniformLocation(program, 'showCircles'),
            showTranscendental: gl.getUniformLocation(program, 'showTranscendental'),
            showGrid: gl.getUniformLocation(program, 'showGrid'),
            showTessellation: gl.getUniformLocation(program, 'showTessellation'),
            transformMatrix: gl.getUniformLocation(program, 'transformMatrix')
        };
        
        // Controls
        const controls = {
            showTunnel: document.getElementById('showTunnel'),
            showCircles: document.getElementById('showCircles'),
            showTranscendental: document.getElementById('showTranscendental'),
            showGrid: document.getElementById('showGrid'),
            showTessellation: document.getElementById('showTessellation'),
            zoom: document.getElementById('zoom'),
            tunnelDepth: document.getElementById('tunnelDepth'),
            lineThickness: document.getElementById('lineThickness'),
            animate: document.getElementById('animate'),
            matrixRotation: document.getElementById('matrixRotation'),
            matrixScale: document.getElementById('matrixScale')
        };
        
        const values = {
            zoomVal: document.getElementById('zoomVal'),
            tunnelDepthVal: document.getElementById('tunnelDepthVal'),
            lineThicknessVal: document.getElementById('lineThicknessVal'),
            matrixRotationVal: document.getElementById('matrixRotationVal'),
            matrixScaleVal: document.getElementById('matrixScaleVal')
        };
        
        // Update value displays
        controls.zoom.addEventListener('input', (e) => {
            values.zoomVal.textContent = e.target.value;
        });
        controls.tunnelDepth.addEventListener('input', (e) => {
            values.tunnelDepthVal.textContent = e.target.value;
        });
        controls.lineThickness.addEventListener('input', (e) => {
            values.lineThicknessVal.textContent = e.target.value;
        });
        controls.matrixRotation.addEventListener('input', (e) => {
            values.matrixRotationVal.textContent = e.target.value + '°';
        });
        controls.matrixScale.addEventListener('input', (e) => {
            values.matrixScaleVal.textContent = e.target.value;
        });
        
        // Render loop
        let startTime = Date.now();
        
        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;
            
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Create transformation matrix from rotation and scale
            const rotation = parseFloat(controls.matrixRotation.value) * Math.PI / 180.0;
            const scale = parseFloat(controls.matrixScale.value);
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);
            
            const transformMatrix = [
                cos * scale, -sin * scale,
                sin * scale,  cos * scale
            ];
            
            gl.uniform2f(uniforms.iResolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.iTime, controls.animate.checked ? currentTime : 0.0);
            gl.uniform1f(uniforms.zoom, parseFloat(controls.zoom.value));
            gl.uniform1f(uniforms.tunnelDepth, parseFloat(controls.tunnelDepth.value));
            gl.uniform1f(uniforms.lineThickness, parseFloat(controls.lineThickness.value));
            gl.uniform1i(uniforms.showTunnel, controls.showTunnel.checked);
            gl.uniform1i(uniforms.showCircles, controls.showCircles.checked);
            gl.uniform1i(uniforms.showTranscendental, controls.showTranscendental.checked);
            gl.uniform1i(uniforms.showGrid, controls.showGrid.checked);
            gl.uniform1i(uniforms.showTessellation, controls.showTessellation.checked);
            gl.uniformMatrix2fv(uniforms.transformMatrix, false, transformMatrix);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        render();
    </script>
</body>
</html>
