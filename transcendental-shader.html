<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperplanar</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: white;
            font-family: monospace;
            overflow: hidden;
        }
        
        glCanvas {
            display: relative;
            margin: 0 auto;
            background: #000;
			z-index: 0;
			position: relative;
        }
        
        glCanvas.fullscreen {
            width: 100vw !important;
            height: 100vh !important;
        }
        
        #controls {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
            display: block;
			z-index: 1;
        }
        
        .controls-toggle {
	        top: 20px;
	        right: 20px;
	        background: rgba(0,0,0,0.9);
	        color: #00ff88;
	        border: 2px solid #00ff88;
	        padding: 10px 15px;
	        border-radius: 8px;
	        cursor: pointer;
	        font-family: monospace;
	        font-size: 12px;
	        font-weight: bold;
			position: relative;
			z-index: 1;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            z-index: 1;
            width: 140px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        input[type="checkbox"] {
            margin-left: 5px;
        }
        
        .value {
            color: #00ff88;
            font-weight: bold;
            font-size: 12px;
        }
        
        h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #00ff88;
        }
        
        button {
            background: var(--button-bg);
            color: var(--button);
            border: var(--button-border);
            padding: 8px 14px;
            border-radius: 2px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 11px;
            font-family: inherit;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            font-weight: normal;
            transition: all 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
			z-index: 1;
        }
        
        button:hover {
            background: var(--button-hover-bg);
            box-shadow: var(--button-hover-shadow);
        }
        
        button:active {
            box-shadow: var(--button-active-shadow);
        }
        
        button.active {
            background: var(--button-active-bg);
            border-color: var(--button-active-border);
        }
        
        button#toggleCtrls {
            top: 20px;
            left: 20px;
            z-index: 1;
        }
        .fullscreen-toggle {
            position: absolute;
			top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: #00ff88;
            border: 2px solid #00ff88;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
			z-index: 1;
        }
        
        .fullscreen-toggle:hover {
            background: rgba(0,255,136,0.2);
        }
 
        .section {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
    </style>
</head>
<body>
	<div id="mainContainer">
	<button class="fullscreen-toggle" id="fullscreenToggle">&#x26F6;</button>
    <button class="controls-toggle" id="toggleCtrls" onclick="hideControls();">&#247;</button>
	<button id="toggleAnim">Start Animation</button>
    <canvas id="glCanvas"></canvas>
    
    <div id="controls">
        <h3>UV Grid transforms</h3>
        
        <div class="control-group">
            <label>Time Speed:</label>
            <input type="range" id="timeSpeed" min="0" max="1" step="0.01" value="0.02">
            <span class="value" id="timeSpeedVal">0.02</span>
        </div>
        
        <h3 class="section">Hyperbolic Geometry</h3>
        
        <div class="control-group">
            <label>Show Transcendental:</label>
            <input type="checkbox" id="showTranscendental" checked>
        </div>
        
        <div class="control-group">
            <label>Show UV Grid:</label>
            <input type="checkbox" id="showTessellation" checked>
        </div>
        
        <div class="control-group">
            <label>Motion Coupling:</label>
            <input type="range" id="motionCoupling" min="0.0" max="2.0" step="0.1" value="0.6">
            <span class="value" id="motionCouplingVal">0.6</span>
        </div>
        
        <h3 class="section">Visual Settings</h3>
        
        <div class="control-group">
            <label>Zoom:</label>
            <input type="range" id="zoom" min="0.5" max="3.0" step="0.1" value="1.2">
            <span class="value" id="zoomVal">3.0</span>
        </div>

        <div class="control-group">
            <label>Line Thickness:</label>
            <input type="range" id="lineThickness" min="0.5" max="5.0" step="0.1" value="3.0">
            <span class="value" id="lineThicknessVal">3.0</span>
        </div>
        
        <div class="control-group">
            <label>UV Transform:</label>
            <input type="range" id="matrixRotation" min="0" max="90" step="1" value="5">
            <span class="value" id="matrixRotationVal">5°</span>
        </div>
        
        <div class="control-group">
            <label>Geometry Opacity:</label>
            <input type="range" id="geometryOpacity" min="0.0" max="1.0" step="0.1" value="0.8">
            <span class="value" id="geometryOpacityVal">0.8</span>
        </div>

    </div>
    </div>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        function hideControls() {
            const contentElement = document.getElementById("controls");
            if (contentElement.style.display === "none") {
                contentElement.style.display = "block";
            } else {
                contentElement.style.display = "none";
            }
        }
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;
        
        // Fragment shader combining RAU celestial mechanics with hyperbolic geometry
        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 iResolution;
            uniform float iTime;
            uniform float phaseTime;
            uniform float zoom;
            uniform float lineThickness;
            uniform float timeSpeed;
            uniform float geometryOpacity;
            uniform float motionCoupling;
            uniform bool showTranscendental;
            uniform bool showTessellation;
            uniform mat2 transformMatrix;
            
            #define PI 3.14159265359
            #define SQRT2 1.41421356237
            
            // Smooth see-saw oscillation function
            float seeSaw(float t) {
                // Creates smooth back-and-forth motion using smoothstep
                float cycle = fract(t);
                return cycle < 0.5 
                    ? smoothstep(0.0, 1.0, cycle * 2.0)
                    : smoothstep(0.0, 1.0, 2.0 - cycle * 2.0);
            }
                        
            // RAU trigonometric functions
            float rsin(float x) {
                float a = 1.0 - 2.0 * x + 2.0 * x * x;
                float invSqrtA = 1.0 / sqrt(a);
                return x * invSqrtA;
            }
            
            float rcos(float x) {
                float a = 1.0 - 2.0 * x + 2.0 * x * x;
                float invSqrtA = 1.0 / sqrt(a);
                return (1.0 - x) * invSqrtA;
            }
            
            vec2 rsincos(float x) {
                float a = 1.0 - 2.0 * x + 2.0 * x * x;
                float invSqrtA = 1.0 / sqrt(a);
                return vec2(x * invSqrtA, (1.0 - x) * invSqrtA);
            }
            
            float degreesToFreq(float degrees) {
                return degrees / 90.0;
            }
            
            vec2 freqRadSinCos(float freq) {
                float phase = mod(freq, 4.0);
                float quadrant = floor(phase);
                float t = phase - quadrant;
                vec2 sc = rsincos(t);
                
                float q0 = step(abs(quadrant - 0.0), 0.1);
                float q1 = step(abs(quadrant - 1.0), 0.1);
                float q2 = step(abs(quadrant - 2.0), 0.1);
                float q3 = step(abs(quadrant - 3.0), 0.1);
                
                vec2 result = vec2(0.0);
                result += q0 * vec2(sc.x, sc.y);
                result += q1 * vec2(sc.y, -sc.x);
                result += q2 * vec2(-sc.x, -sc.y);
                result += q3 * vec2(-sc.y, sc.x);
                
                return result;
            }
            
            // Distance functions for hyperbolic geometry
            float line(vec2 p, vec2 a, vec2 b) {
                p -= a;
                b -= a;
                float h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);
                return length(p - b * h);
            }
            
            float circle(vec2 p, float r) {
                return abs(length(p) - r);
            }
            
            // UV coordinate transformation
            vec2 xyToUV(vec2 p) {
                float u = pow(cos(PI / max(abs(p.x), 0.01)), 2.0);
                float v = pow(sin(PI / max(abs(p.y), 0.01)), 2.0);
                return vec2(u, v);
            }
            
            // Transcendental field with smooth oscillation
            float transcendentalDist(vec2 p, out vec3 color) {
                if (abs(p.x) < 0.01 || abs(p.y) < 0.01) {
                    color = vec3(0.0);
                    return 1000.0;
                }
                
                float cosX = cos(PI / p.x);
                float sinY = sin(PI / p.y);
                float val = cosX * cosX + sinY * sinY;
                
                // Smooth oscillation for coloring
                float osc = seeSaw(phaseTime);
                float pulse = 0.6 + 0.4 * osc;
                
                // Rainbow-like color cycling
                float hue = val * 2.0 + osc * motionCoupling;
                color = vec3(
                    0.5 + 0.5 * sin(hue * PI * 2.0),
                    0.5 + 0.5 * cos(hue * PI * 1.7),
                    0.7 + 0.3 * sin(hue * PI * 2.3)
                ) * pulse;
                
                return abs(val - 1.0) * 2.0;
            }
            
            // UV tessellation with oscillation
            float uvTessellation(vec2 p, out vec3 color) {
                vec2 uv = xyToUV(p);
                uv = transformMatrix * uv;
                
                // Apply oscillating warp
                float osc = seeSaw(phaseTime);
                float warp = (osc - 0.5) * motionCoupling * 0.15;
                uv += warp;
                
                vec2 gridUV = fract(uv * 10.0);
                gridUV = abs(gridUV - 0.5);
                
                // Animated grid coloring
                float wave = sin(uv.x * PI * 3.0) * cos(uv.y * PI * 3.0);
                float brightness = 0.5 + 0.5 * osc;
                
                color = vec3(
                    brightness * (0.4 + 0.6 * osc),
                    brightness * (0.6 + 0.4 * sin(osc * PI)),
                    brightness * (0.8 + 0.2 * cos(osc * PI * 1.5))
                );
                
                return min(gridUV.x, gridUV.y) * 2.0;
            }
            
            // Equatorial to projection using oscillation for rotation
            vec2 equatorialToProjection(float ra, float dec) {
                // Use oscillation phase to drive rotation (24 hour period)
                float phaseTime = phaseTime * 24.0;
                float ha = phaseTime - ra;
                ha = mod(ha + 12.0, 24.0) - 12.0;
                
                dec = clamp(dec, -90.0, 90.0);
                float polarDistance = 90.0 - dec;
                float projRadius = tan(clamp(polarDistance, 0.0, 120.0) * PI / 360.0);
                projRadius = min(projRadius, 5.0);
                
                float polarAngle = ha * 15.0; // hours to degrees
                vec2 angleTrig = freqRadSinCos(polarAngle / 90.0); // to RAU freq
                
                return projRadius * 0.8 * angleTrig;
            }

            // Render hyperbolic geometry with motion-driven effects
            vec4 renderGeometry(vec2 uv) {
                float d = 1000.0;
                vec3 color = vec3(0.0);
                vec3 tempColor;
                
                // Transcendental grid with animated lighting
                if (showTranscendental) {
                    float transDist = transcendentalDist(uv, tempColor);
                    if (transDist < d) {
                        d = transDist;
                        color = tempColor;
                    }
                }
                
                // UV tessellation with motion coupling
                if (showTessellation) {
                    float tessDist = uvTessellation(uv, tempColor);
                    if (tessDist < d) {
                        d = tessDist;
                        color = tempColor;
                    }
                }
                
                float thickness = lineThickness / iResolution.y * 30.0;
                float alpha = (1.0 - smoothstep(0.0, thickness, d));
                
                return vec4(color * alpha * geometryOpacity, alpha * geometryOpacity);
            }
            
            void main() {
                vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;
                uv *= zoom;
                
                // Background gradient
                float radialDist = length(uv);
                vec3 color = vec3(0.01, 0.03, 0.06) * (1.0 - radialDist * 0.4);
                
                // Render hyperbolic geometry
                vec4 geom = renderGeometry(uv);
                color = mix(color, geom.rgb, geom.a);

                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        // Geometry
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Uniforms
        const uniforms = {
            iResolution: gl.getUniformLocation(program, 'iResolution'),
            iTime: gl.getUniformLocation(program, 'iTime'),
            phaseTime: gl.getUniformLocation(program, 'phaseTime'),
            latitude: gl.getUniformLocation(program, 'latitude'),
            zoom: gl.getUniformLocation(program, 'zoom'),
            lineThickness: gl.getUniformLocation(program, 'lineThickness'),
            timeSpeed: gl.getUniformLocation(program, 'timeSpeed'),
            geometryOpacity: gl.getUniformLocation(program, 'geometryOpacity'),
            motionCoupling: gl.getUniformLocation(program, 'motionCoupling'),
            showTranscendental: gl.getUniformLocation(program, 'showTranscendental'),
            showTessellation: gl.getUniformLocation(program, 'showTessellation'),
            transformMatrix: gl.getUniformLocation(program, 'transformMatrix')
        };
        
        // Controls
        const controls = {
            showTranscendental: document.getElementById('showTranscendental'),
            showTessellation: document.getElementById('showTessellation'),
            timeSpeed: document.getElementById('timeSpeed'),
            zoom: document.getElementById('zoom'),
            lineThickness: document.getElementById('lineThickness'),
            matrixRotation: document.getElementById('matrixRotation'),
            geometryOpacity: document.getElementById('geometryOpacity'),
            motionCoupling: document.getElementById('motionCoupling'),
        };
        const toggleAnimBtn = document.getElementById('toggleAnim');
        let phaseTime = 0;
        let animating = false;
        let startTime = Date.now();
        let zoomInvert = 0.0;
		// ------------------ TRIANGLE WAVE ------------------
		function triC(t) {
			// Returns -1 → 1 → -1 with constant speed
			return 2.0 * Math.abs((t % 2) - 1) - 2.0;
		}

   		controls.zoom.addEventListener('input', (event) => {
   		  const rawValue = parseFloat(event.target.value, 0.01);
   		  const min = parseFloat(controls.zoom.min, 0.01);
   		  const max = parseFloat(controls.zoom.max-0.01, 0.01);
   		
   		  // Calculate the reversed value
   		  const reversedValue = max - (rawValue - min); 
   		  
   		  document.getElementById('zoomVal').textContent = rawValue;
   		});
   		
        function updateDisplays() {
            document.getElementById('timeSpeedVal').textContent = controls.timeSpeed.value;
            document.getElementById('lineThicknessVal').textContent = controls.lineThickness.value;
            document.getElementById('matrixRotationVal').textContent = controls.matrixRotation.value + '°';
            document.getElementById('geometryOpacityVal').textContent = controls.geometryOpacity.value;
            document.getElementById('motionCouplingVal').textContent = controls.motionCoupling.value;
        }

        // ------------------ START/STOP ANIMATION ------------------
        function toggleAnimation() {
        	animating = !animating;

        	if (animating) {
        		toggleAnimBtn.textContent = "Stop Animation";
        		toggleAnimBtn.classList.add("active");
        		t0_ZR = performance.now();
        	} else {
        		toggleAnimBtn.textContent = "Start Animation";
        		toggleAnimBtn.classList.remove("active");
        	}
        }
        // Double-click canvas to toggle animation (legacy support)
        canvas.addEventListener('dblclick', toggleAnimation);
        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;
            
            if (animating) {
                const timeSpeed = parseFloat(controls.timeSpeed.value);
                phaseTime += timeSpeed * 0.016;
                if (phaseTime >= 24) phaseTime = -24;
            }
            
            const rotation = parseFloat(controls.matrixRotation.value) * Math.PI / 180.0;
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);
            const transformMatrix = [cos, -sin, sin, cos];
            
            gl.uniform2f(uniforms.iResolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.iTime, currentTime);
            gl.uniform1f(uniforms.phaseTime, phaseTime);
            gl.uniform1f(uniforms.zoom, controls.zoom.max-0.02-parseFloat(controls.zoom.value));
            gl.uniform1f(uniforms.lineThickness, parseFloat(controls.lineThickness.value));
            gl.uniform1f(uniforms.timeSpeed, parseFloat(controls.timeSpeed.value));
            gl.uniform1f(uniforms.geometryOpacity, parseFloat(controls.geometryOpacity.value));
            gl.uniform1f(uniforms.motionCoupling, parseFloat(controls.motionCoupling.value));
            gl.uniform1i(uniforms.showTranscendental, controls.showTranscendental.checked);
            gl.uniform1i(uniforms.showTessellation, controls.showTessellation.checked);
            gl.uniformMatrix2fv(uniforms.transformMatrix, false, transformMatrix);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            updateDisplays();
            requestAnimationFrame(render);
        }
        
        // Event listeners
        Object.keys(controls).forEach(key => {
            controls[key].addEventListener('input', updateDisplays);
            controls[key].addEventListener('change', updateDisplays);
        });
        
        document.getElementById('toggleAnim').addEventListener('click', () => {
            animating = !animating;
            const btn = document.getElementById('toggleAnim');
            if (animating) {
                btn.textContent = 'Stop Animation';
                btn.classList.add('active');
            } else {
                btn.textContent = 'Start Animation';
                btn.classList.remove('active');
            }
        });
        
        updateDisplays();
        requestAnimationFrame(render);
        
        function cancelFullScreen() {
            var el = document;
            var requestMethod = el.cancelFullScreen||el.webkitCancelFullScreen||el.mozCancelFullScreen||el.exitFullscreen||el.webkitExitFullscreen;
            if (requestMethod) { // cancel full screen.
                requestMethod.call(el);
            } else if (typeof window.ActiveXObject !== "undefined") { // Older IE.
                var wscript = new ActiveXObject("WScript.Shell");
                if (wscript !== null) {
                    wscript.SendKeys("{F11}");
                }
            }
        }

        function requestFullScreen(el) {
            // Supports most browsers and their versions.
            var requestMethod = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullscreen;

            if (requestMethod) { // Native full screen.
                requestMethod.call(el);
            } else if (typeof window.ActiveXObject !== "undefined") { // Older IE.
                var wscript = new ActiveXObject("WScript.Shell");
                if (wscript !== null) {
                    wscript.SendKeys("{F11}");
                }
            }
            return false
        }
          
        // Fullscreen toggle
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        fullscreenToggle.addEventListener('click', () => {
            canvas.classList.toggle('fullscreen');
            var isInFullScreen = (document.fullScreenElement && document.fullScreenElement !== null) ||  (document.mozFullScreen || document.webkitIsFullScreen);

            // Update canvas resolution when toggling fullscreen
            if (canvas.classList.contains('fullscreen')) {
                canvas.height = canvas.height*2;
                canvas.width = canvas.width*2;
				canvas.style.top = (parseInt(canvas.style.top) || 0 - 50) + 'px';
				if (!el) {
                el = document.body; // Make the body go full screen.
				}

				requestFullScreen(el);
				var el = document.documentElement,
					rfs = el.requestFullscreen;
				if(typeof rfs!="undefined" && rfs){
					rfs.call(el);
				}
				
            } else {
				cancelFullScreen();

				canvas.style.top = '0px';
                canvas.width = 960;
                canvas.height = 720;
            }
            
            // Update center coordinates
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            render();
        });
    </script>
</body>
</html>
