<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperbolic Plane/Grid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: white;
            font-family: monospace;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            background: #000;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ff88;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            width: 140px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        input[type="checkbox"] {
            margin-left: 5px;
        }
        
        .value {
            color: #00ff88;
            font-weight: bold;
            font-size: 12px;
        }
        
        h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="960" height="720"></canvas>
    
    <div class="controls">
        <h3>Transcendental Grid</h3>
        
        <div class="control-group">
            <label>Show 45° Lines:</label>
            <input type="checkbox" id="showDiagonals" checked>
        </div>
        
        <div class="control-group">
            <label>Radical Mode (RAU):</label>
            <input type="checkbox" id="radicalMode">
        </div>
        
        <div class="control-group">
            <label>Zoom:</label>
            <input type="range" id="zoom" min="0.2" max="3.0" step="0.1" value="1.0">
            <span class="value" id="zoomVal">1.0</span>
        </div>
        
        <div class="control-group">
            <label>Resolution:</label>
            <input type="range" id="resolution" min="50" max="400" step="10" value="200">
            <span class="value" id="resolutionVal">200</span>
        </div>
        
        <div class="control-group">
            <label>Line Alpha:</label>
            <input type="range" id="lineAlpha" min="0.1" max="1.0" step="0.1" value="0.6">
            <span class="value" id="lineAlphaVal">0.6</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        const controls = {
            radicalMode: document.getElementById('radicalMode'),
            zoom: document.getElementById('zoom'),
            resolution: document.getElementById('resolution'),
            lineAlpha: document.getElementById('lineAlpha'),
            showDiagonals: document.getElementById('showDiagonals'),
        };
        
        const values = {
            zoomVal: document.getElementById('zoomVal'),
            resolutionVal: document.getElementById('resolutionVal'),
            lineAlphaVal: document.getElementById('lineAlphaVal')
        };
        
        // Update displays
        controls.zoom.addEventListener('input', (e) => {
            values.zoomVal.textContent = e.target.value;
            render();
        });
        controls.resolution.addEventListener('input', (e) => {
            values.resolutionVal.textContent = e.target.value;
            render();
        });
        controls.lineAlpha.addEventListener('input', (e) => {
            values.lineAlphaVal.textContent = e.target.value;
            render();
        });
        
        // Trigger render on checkbox changes
        Object.keys(controls).forEach(key => {
            if (controls[key].type === 'checkbox') {
                controls[key].addEventListener('change', render);
            }
        });
        
        // RAU (Radical Angle Unit) functions
        function fastInvSqrt(x) {
            // Approximation for 1/sqrt(x)
            return 1.0 / Math.sqrt(x);
        }
        
        function rauSin(t) {
            // Normalize t to [0, 4) range
            t = ((t % 4) + 4) % 4;
            const quadrant = Math.floor(t);
            const local = t - quadrant;
            
            // Base radical functions
            const a = 1.0 - 2.0 * local + 2.0 * local * local;
            const invSqrtA = fastInvSqrt(a);
            const s = local * invSqrtA;
            const c = (1.0 - local) * invSqrtA;
            
            // Quadrant mapping
            switch(quadrant) {
                case 0: return s;
                case 1: return c;
                case 2: return -s;
                case 3: return -c;
                default: return 0;
            }
        }
        
        function rauCos(t) {
            // Normalize t to [0, 4) range
            t = ((t % 4) + 4) % 4;
            const quadrant = Math.floor(t);
            const local = t - quadrant;
            
            // Base radical functions
            const a = 1.0 - 2.0 * local + 2.0 * local * local;
            const invSqrtA = fastInvSqrt(a);
            const s = local * invSqrtA;
            const c = (1.0 - local) * invSqrtA;
            
            // Quadrant mapping
            switch(quadrant) {
                case 0: return c;
                case 1: return -s;
                case 2: return -c;
                case 3: return s;
                default: return 1;
            }
        }
        
        // Convert canvas coordinates to world coordinates
        function canvasToWorld(x, y, zoom) {
            return {
                x: (x - centerX) / (centerX * 0.8) * zoom,
                y: -(y - centerY) / (centerY * 0.8) * zoom
            };
        }
        
        // Convert world coordinates to canvas coordinates
        function worldToCanvas(x, y, zoom) {
            return {
                x: centerX + (x / zoom) * (centerX * 0.8),
                y: centerY - (y / zoom) * (centerY * 0.8)
            };
        }
        
        // Evaluate transcendental equation
        function evaluateTranscendental(x, y, useRadical) {
            if (Math.abs(x) < 0.01 || Math.abs(y) < 0.01) return null;
            
            let cosX, sinY;
            
            if (useRadical) {
                // RAU mode: use 4.0 instead of PI
                cosX = rauCos(4.0 / x);
                sinY = rauSin(4.0 / y);
            } else {
                // Standard mode: use PI
                cosX = Math.cos(Math.PI / x);
                sinY = Math.sin(Math.PI / y);
            }
            
            return cosX * cosX + sinY * sinY;
        }
        
        // Draw transcendental equation curves
        function drawTranscendental(zoom, resolution, alpha, useRadical) {
            ctx.strokeStyle = `rgba(255, 0, 255, ${alpha})`;
            ctx.lineWidth = 2;
            
            const step = canvas.width / resolution;
            
            // Scan through pixels and find where equation ≈ 1
            for (let px = 0; px < canvas.width; px += step) {
                for (let py = 0; py < canvas.height; py += step) {
                    const world = canvasToWorld(px, py, zoom);
                    const val = evaluateTranscendental(world.x, world.y, useRadical);
                    
                    if (val !== null && Math.abs(val - 1.0) < 0.15) {
                        // Check neighbors to draw continuous lines
                        const worldRight = canvasToWorld(px + step, py, zoom);
                        const worldDown = canvasToWorld(px, py + step, zoom);
                        
                        const valRight = evaluateTranscendental(worldRight.x, worldRight.y, useRadical);
                        const valDown = evaluateTranscendental(worldDown.x, worldDown.y, useRadical);
                        
                        ctx.beginPath();
                        
                        if (valRight !== null && Math.abs(valRight - 1.0) < 0.15) {
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + step, py);
                        }
                        
                        if (valDown !== null && Math.abs(valDown - 1.0) < 0.15) {
                            ctx.moveTo(px, py);
                            ctx.lineTo(px, py + step);
                        }
                        
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Draw 45° diagonal lines
        function drawDiagonals(zoom, alpha) {
            ctx.strokeStyle = `rgba(100, 255, 100, ${alpha * 0.5})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            const extent = 10;
            
            // 45° lines
            const lines = [
                [{x: -extent, y: -extent}, {x: extent, y: extent}],   // 45°
                [{x: -extent, y: extent}, {x: extent, y: -extent}],   // 135°
            ];
            
            lines.forEach(line => {
                const start = worldToCanvas(line[0].x, line[0].y, zoom);
                const end = worldToCanvas(line[1].x, line[1].y, zoom);
                
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            });
            
            ctx.setLineDash([]);
        }
        
        // Draw axes
        function drawAxes(zoom, alpha) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
            ctx.lineWidth = 2;
            
            const extent = 10;
            
            // X-axis
            const xLeft = worldToCanvas(-extent, 0, zoom);
            const xRight = worldToCanvas(extent, 0, zoom);
            ctx.beginPath();
            ctx.moveTo(xLeft.x, xLeft.y);
            ctx.lineTo(xRight.x, xRight.y);
            ctx.stroke();
            
            // Y-axis
            const yTop = worldToCanvas(0, extent, zoom);
            const yBottom = worldToCanvas(0, -extent, zoom);
            ctx.beginPath();
            ctx.moveTo(yTop.x, yTop.y);
            ctx.lineTo(yBottom.x, yBottom.y);
            ctx.stroke();
        }
        
        // Main render function
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const zoom = parseFloat(controls.zoom.value);
            const resolution = parseInt(controls.resolution.value);
            const alpha = parseFloat(controls.lineAlpha.value);
            const useRadical = controls.radicalMode.checked;

            drawAxes(zoom, alpha);
            
            if (controls.showDiagonals.checked) {
                drawDiagonals(zoom, alpha);
            }
            
            drawTranscendental(zoom, resolution, alpha, useRadical);
            // Draw center point
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Initial render
        render();
    </script>
</body>
</html>
